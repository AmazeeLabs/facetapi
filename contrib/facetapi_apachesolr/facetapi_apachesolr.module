<?php
// $Id$

/**
 * @file
 * The Apache Solr Search Integration module's implementation of the the Facet
 * API.
 */

/**
 * Implementation of hook_menu().
 */
function facetapi_apachesolr_menu() {
  $items = array();

  $items['admin/settings/apachesolr/facets'] = array(
    'title' => 'Facets',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('facetapi_admin_settings_form', 'apachesolr_search'),
    'access arguments' => array('administer search'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'facetapi.admin.inc',
    'file path' => drupal_get_path('module', 'facetapi'),
    'weight' => 10,
  );

  return $items;
}

/**
 * Implementation of hook_facetapi_adapters().
 */
function facetapi_apachesolr_facetapi_adapters() {
  return array(
    'apachesolr_search' => array(
      'class' => 'FacetapiApachesolrAdapter',
      'type' => 'node',
      'file' => 'facetapi_apachesolr.adapter.inc',
    ),
  );
}

/**
 * Implementation of hook_facetapi_facets_alter().
 */
function facetapi_apachesolr_facetapi_facets_alter(array &$facets, $searcher, $type) {
  if ('apachesolr_search' == $searcher) {
    foreach ($facets as &$facet) {
      if (preg_match('/^vocabulary_(\d+)$/', $facet['name'], $matches)) {
        $facet['field'] = 'im_vid_'. $matches[1];;
        $facet['field alias'] = 'tid';
      }
    }
    unset($facet);
  }
}

/**
 * Implementation of hook_apachesolr_prepare_query().
 */
function facetapi_apachesolr_apachesolr_prepare_query($query, &$params, $caller) {
  facetapi_query_type_hooks_invoke('apachesolr_search', $params, $query);
}

/**
 * Implementation of hook_facetapi_query_TYPE_process().
 */
function facetapi_apachesolr_facetapi_query_term_process(FacetapiAdapter $adapter, array $facet, &$params, $query) {
  $searcher = $adapter->getSearcher();

  // Adds the operator parameter.
  $operator = facetapi_setting_get('operator', $searcher, '', $facet['name']);
  $ex = (FACETAPI_OPERATOR_OR != $operator) ? '' : "{!ex={$facet['field']}}";
  $params['facet.field'][] = $ex . $facet['field'];

  // Adds "hard limit" parameter to prevent too many return values.
  $limit = facetapi_setting_get('hard_limit', $searcher, '', $facet['name']);
  $params['f.'. $facet['field'] .'.facet.limit'] = ($limit !== NULL) ? (int)$limit : 20;
}

/**
 * Implementation of hook_facetapi_query_TYPE_process().
 */
function facetapi_apachesolr_facetapi_query_date_process(FacetapiAdapter $adapter, array $facet, &$params, $query) {
  $searcher = $adapter->getSearcher();

  // Loads date functions, gets the range information.
  // @todo remove the assumption that ranges are dates.
  list($start, $end, $gap) = facetapi_apachesolr_date_range($query, $facet['field']);

  $params['facet.date'][] = $facet['field'];
  $params['f.'. $facet['field'] .'.facet.date.start'] = $start;
  $params['f.'. $facet['field'] .'.facet.date.end'] = $end;
  $params['f.'. $facet['field'] .'.facet.date.gap'] = $gap;

  // Adds "hard limit" parameter to prevent too many return values.
  $limit = facetapi_setting_get('hard_limit', $searcher, '', $facet['name']);
  $params['f.'. $facet['field'] .'.facet.limit'] = ($limit !== NULL) ? (int)$limit : 20;
}

/**
 * Gets the range of dates we are using.
 *
 * @param $query
 *   A Solr_Base_Query object.
 * @param $facet_field
 *   A string containing the name of the facet field.
 * @return
 *   An array containing the gap and range information.
 * @todo integrate this into facetapi_apachesolr_facetapi_date_range_process()
 *       once we have a "range limit callback".
 */
function facetapi_apachesolr_date_range(Solr_Base_Query $query, $facet_field) {
  foreach ($query->get_filters($facet_field) as $filter) {

    // If we had an ISO date library we could use ISO dates directly. Instead,
    // we convert to Unix timestamps for comparison. Only use dates if we are
    // able to parse into timestamps.
    $start = strtotime($filter['#start']);
    $end = strtotime($filter['#end']);


    if ($start && $end && ($start < $end)) {
      $start_date = $filter['#start'];
      $end_date = $filter['#end'];
      // Determine the drilldown gap for this range.
      $gap = facetapi_gap_drilldown(facetapi_query_gap_get($start_date, $end_date));
    }
  }

  // If there is no $delta field in query object, get initial facet.date.*
  // params from the DB and determine the best search gap to use. This callback
  // assumes $delta is 'changed' or 'created'.
  if (!isset($start_date)) {

    // @todo Cache this, because it could be intensive.
    $start_date = facetapi_isodate(db_result(db_query("SELECT MIN($facet_field) FROM {node} WHERE status = 1")));
    // Subtract one second, so that this range's $end_date is not equal to the
    // next range's $start_date.
    $end_date = facetapi_isodate(db_result(db_query("SELECT MAX($facet_field) FROM {node} WHERE status = 1")) - 1);
    $gap = facetapi_date_gap_get($start_date, $end_date);
  }

  // Return a query range from the beginning of a gap period to the beginning of
  // the next gap period.  We ALWAYS generate query ranges of this form and the
  // facetapi_*() helper functions require it.
  return array("$start_date/$gap", "$end_date+1$gap/$gap", "+1$gap");
}
