<?php
// $Id$

/**
 * @file
 * The Search Lucene API module's implementation of the the Facet API.
 */

/**
 * Implementation of hook_menu().
 */
function facetapi_luceneapi_menu() {
  $items = array();

  // Iterates over all searchable modules, adds menu items.
  foreach (luceneapi_searchable_module_list() as $searcher => $name) {
    $items['admin/settings/'. $searcher .'/facetapi'] = array(
      'title' => 'Facets',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('facetapi_admin_settings_form', $searcher),
      'access arguments' => array('administer search'),
      'type' => MENU_LOCAL_TASK,
      'file' => 'facetapi.admin.inc',
      'file path' => drupal_get_path('module', 'facetapi'),
      'weight' => 10,
    );
  }

  return $items;
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function facetapi_luceneapi_form_facetapi_admin_settings_form_alter(&$form, $form_state) {
  if ('luceneapi_node' == $form['storage']['#value']['searcher']) {
    $form['storage']['#value']['enabled'] = facetapi_enabled_facets_get($form['storage']['#value']['searcher']);
    $form['#submit'][] = 'facetapi_luceneapi_form_facetapi_admin_settings_form';
  }
}

/**
 * Processes facetapi_admin_settings_form form submissions.
 */
function facetapi_luceneapi_form_facetapi_admin_settings_form(&$form, &$form_state) {
  $searcher = $form['storage']['#value']['searcher'];

  // Gets the newly enabled facets.
  $enabled_facets = array_diff_key(
    facetapi_enabled_facets_get($searcher, NULL, TRUE),
    $form['storage']['#value']['enabled']
  );

  // If facets have been enabled, re-populates termFreqs cache.
  if (!empty($enabled_facets)) {
    $batch = array(
      'operations' => array(),
      'title' => t('Rebuilding termFreqs cache'),
      'init_message' => t('Populating ...'),
      'progress_message' => t('Batch @current out of @total'),
      'error_message' => t('An error occurred populating the cache.'),
    );

    // Iterates over facets, adds batch process to populate termFreqs cache.
    foreach ($enabled_facets as $facet) {
      $variable = 'facetapi:termfreqs_cached:'. $searcher .':::'. $facet['field'];
      variable_set($variable, TRUE);
      $batch['operations'][] = array('facetapi_luceneapi_termfreqs_populate', array(
        $searcher, $facet['field']
      ));
    }

    // Let the batch begin!
    batch_set($batch);
    drupal_set_message(t('The termFreqs cache has been rebuilt.'));
  }
}

/**
 * Implementation of hook_facetapi_facets_alter().
 */
function facetapi_luceneapi_facetapi_facets_alter(array &$facets, $searcher, $type) {
  if ('luceneapi_node' == $searcher) {
    foreach ($facets as &$facet) {
      if (preg_match('/^vocabulary_(\d+)$/', $facet['name'], $matches)) {
        $facet['field'] = 'category_'. $matches[1];;
        $facet['field alias'] = 'category';
      }
    }
    unset($facet);
  }
}

/**
 * Implementation of hook_facetapi_adapters().
 */
function facetapi_luceneapi_facetapi_adapters() {
  $adapters = array();

  // Iterates over searchable Search Lucene API modules, builds adapter information.
  foreach (luceneapi_searchable_module_list() as $searcher => $name) {
    $adapters[$searcher] = array(
      'class' => 'FacetapiLuceneapiAdapter',
      'type' => luceneapi_index_type_get($searcher),
      'file' => 'facetapi_luceneapi.adapter.inc',
    );
  }

  return $adapters;
}

/**
 * Helper function to get the wildcard prefix.
 *
 * @param $text
 *   A string containing the text prefix is being extracted from.
 * @return
 *   A string containing the prefix.
 */
function facetapi_luceneapi_prefix_get($text) {
  $q_pos = strpos($text, '?');
  $a_pos = strpos($text, '*');
  if ($q_pos !== false) {
    if ($a_pos !== false) {
      return substr($text, 0, min($q_pos, $a_pos));
    }
    return substr($text, 0, $q_pos);
  }
  elseif ($a_pos !== false) {
    return substr($text, 0, $a_pos);
  }
  return $text;
}

/**
 * Reads termfrequencies from the lookup table to avoid having to calculate it
 * on the fly, which is very performance intensive.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $term
 *   A Zend_Search_Lucene_Index_Term object.
 * @return
 *   An array keyed by Lucene document ID to term frequency.
 */
function facetapi_luceneapi_termfreqs_get($searcher, Zend_Search_Lucene_Index_Term $term) {
  static $cache = array();

  // If cache is not populated for the field, reads the field's cached data.
  if (!isset($cache[$searcher][$term->field])) {

    $variable = 'facetapi:termfreqs_cached:'. $searcher .':::'. $term->field;
    if (!variable_get($variable, FALSE)) {
      facetapi_luceneapi_termfreqs_populate($searcher, $term->field);
      variable_set($variable, TRUE);
    }

    // Reads term frequencies from the database.
    $cache[$searcher][$term->field] = array();
    $table = '{'. $searcher .'_termfreqs}';
    $sql = "SELECT term, termfreqs FROM $table WHERE field = '%s'";
    if ($result = db_query($sql, array($term->field))) {
      while ($record = db_fetch_object($result)) {
        $cache[$searcher][$term->field][$record->term] = array(
          'termfreqs' => $record->termfreqs,
          'unserialized' => FALSE,
        );
      }
    }
  }

  // Returns array of termfreqs, unserializes if necessary.
  if (isset($cache[$searcher][$term->field][$term->text])) {
    $data = &$cache[$searcher][$term->field][$term->text];
    if (empty($data['unserialized'])) {
      $data['termfreqs'] = unserialize($data['termfreqs']);
      $data['unserialized'] = TRUE;
    }
    return $data['termfreqs'];
  }
  else {
    return array();
  }
}

/**
 * Gets the filter counts for an array of terms.
 *
 * @param $index
 *   A LuceneAPI_Search_Lucene_Proxy object, such as the one returned by the
 *   luceneapi_index_open() function.
 * @param $docs
 *   An array of documents keyed by docuent ID to score.
 * @param $terms
 *   An array of Zend_Search_Lucene_Index_Term objects.
 */
function facetapi_luceneapi_terms_count(Zend_Search_Lucene_Proxy $index, array $docs, array $terms) {
  $freqs = array();

  // Reading from a termFreqs cache table is MUCH more efficient than
  // calculating them on the fly for every search.
  foreach ($terms as $term) {
    $freqs += facetapi_luceneapi_termfreqs_get('luceneapi_node', $term);
  }

  // NOTE: This is surprisingly efficient.
  return count(array_intersect_key($docs, $freqs));
}

/**
 * Rewrites a wildcard query into primitive terms.
 *
 * @param $index
 *   A Zend_Search_Lucene_Interface object, such as the one returned by the
 *   luceneapi_index_open() function.
 * @param $text
 *   A string containing the text being parsed.
 * @param $fields
 *   An array of fields the terms are matched against.
 * @return
 *   An array of Zend_Search_Lucene_Index_Term objects.
 */
function facetapi_luceneapi_wildcard_matches_get(Zend_Search_Lucene_Interface $index, $text, array $fields = array('contents')) {

  // Prevents too many terms from being extracted.
  $max_terms = Zend_Search_Lucene::getTermsPerQueryLimit();

  // Gets the word prefix.
  $prefix = facetapi_luceneapi_prefix_get($text);
  $prefix_len = strlen($prefix);
  $pattern = '/^'. str_replace(array('\\?', '\\*'), array('.', '.*'), preg_quote($text, '/')) .'$/';

  // Caclulates matches.
  $matches = array();
  foreach ($fields as $field) {
    $index->resetTermsStream();
    $index->skipTo(new Zend_Search_Lucene_Index_Term($prefix, $field));
    while ($index->currentTerm() !== NULL && $index->currentTerm()->field == $field) {
      if ($prefix != '' && substr($index->currentTerm()->text, 0, $prefix_len) != $prefix) {
        break;
      }
      if (preg_match($pattern, $index->currentTerm()->text) === 1) {
        $matches[] = $index->currentTerm();
        // Terms per query limit reached.
        if ($max_terms != 0 && count($matches) > $max_terms) {
          throw new Zend_Search_Lucene_Exception('Terms per query limit is reached.');
        }
      }
      $index->nextTerm();
    }
    $index->closeTermsStream();
  }

  return $matches;
}

/**
 * Rewrites a range query into primitive terms.
 *
 * @param $index
 *   A Zend_Search_Lucene_Interface object, such as the one returned by the
 *   luceneapi_index_open() function.
 * @param $lower
 *   A string containing the lower boundary.
 * @param $upper
 *   A string containing the upper boundary.
 * @param $inclusive
 *   A boolean flagging whether to include the upper term in the result set.
 * @param $fields
 *   An array of fields the terms are matched against.
 * @return
 *   An array of Zend_Search_Lucene_Index_Term objects.
 */
function facetapi_luceneapi_range_matches_get(Zend_Search_Lucene_Interface $index, $lower, $upper, $inclusive = FALSE, array $fields = array('contents')) {

  // Prevents too many terms from being extracted.
  $max_terms = Zend_Search_Lucene::getTermsPerQueryLimit();

  $matches = array();
  foreach ($fields as $field) {
    $index->resetTermsStream();

    if ($lower !== NULL) {
      $lower_term = new Zend_Search_Lucene_Index_Term($lower, $field);
      $index->skipTo($lower_term);

      if (!$inclusive && $index->currentTerm() == $lower_term) {
        $index->nextTerm();
      }
    }
    else {
      $index->skipTo(new Zend_Search_Lucene_Index_Term('', $field));
    }

    if ($upper !== NULL) {
      // Walk up to the upper term
      $upper_term = new Zend_Search_Lucene_Index_Term($upper, $field);

      while (
        $index->currentTerm() !== NULL &&
        $index->currentTerm()->field == $field &&
        $index->currentTerm()->text < $upper_term->text
      ) {

        $matches[] = $index->currentTerm();
        if ($max_terms != 0 && count($matches) > $max_terms) {
          throw new Zend_Search_Lucene_Exception('Terms per query limit is reached.');
        }
        $index->nextTerm();
      }

      if ($inclusive && $index->currentTerm() == $upper_term) {
        // Include upper term into result
        $matches[] = $upper_term;
      }
    }
    else {
      // Walk up to the end of field data
      while ($index->currentTerm() !== NULL && $index->currentTerm()->field == $field) {
        $matches[] = $index->currentTerm();
        if ($max_terms != 0 && count($matches) > $max_terms) {
          throw new Zend_Search_Lucene_Exception('Terms per query limit is reached.');
        }
        $index->nextTerm();
      }
    }

    $index->closeTermsStream();
  }

  return $matches;
}

/**
 * Populates the termfreqs() database for the specified fields.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $fields
 *   An array containing the fields the termFreqs cache is being populated for.
 * @param &$context
 *   An optional array containing the batch context when using this function as
 *   a batch operation.
 * @return
 *   NULL
 */
function facetapi_luceneapi_termfreqs_populate($searcher, $fields = NULL, &$context = NULL) {
  if (!$index = luceneapi_index_open($searcher)) {
    return;
  }

  // Gets fields, defaults to all enabled facets.
  if (NULL === $fields) {
    $fields = array();
    foreach (facetapi_enabled_facets_get('luceneapi_node') as $facet) {
      $fields[$facet['field']] = $facet['field'];
    }
  }
  else {
    $fields = drupal_map_assoc((array)$fields);
  }

  // Sets message if this is a batch process.
  if (NULL !== $context) {
    $context['message'] = format_plural(
      count($fields),
      'Populating termFreqs cache for the %fields field',
      'Populating termFreqs cache for the %fields fields',
      array('%fields' => join(', ', $fields))
    );
  }

  // Gets terms from index.
  $terms = array();
  foreach ($index->terms() as $term) {
    if (isset($fields[$term->field])) {
      $terms[$term->field][$term->text] = $index->termFreqs($term);
    }
  }

  // Populates termfreqs cache for all passed fields.
  $table = '{'. $searcher .'_termfreqs}';
  foreach ($terms as $field => $field_terms) {

    // Builds placeholders and values.
    $values = $placeholders = array();
    foreach ($field_terms as $term => $termfreqs) {
      $placeholders[] = "('%s', '%s', '%s')";
      $values[] = $term;
      $values[] = $field;
      $values[] = serialize($termfreqs);
    }

    // If there are values, inserts data.
    if (!empty($values)) {
      $sql = "DELETE FROM $table WHERE field = '%s'";
      db_query($sql, array($field));

      // @todo Batch in groups of 100? 1000?  OK as is?
      $sql = "INSERT INTO $table (term, field, termfreqs) VALUES ". join(',', $placeholders);
      db_query($sql, $values);
    }
  }
}

/**
 * Converts all timestamps in an array to dates in ISO 8601 format.
 *
 * @param &$value
 *   An integer containing the timestamp.
 * @param $key
 *   An integer containing the array key.
 * @param $format
 *   A string containing the date string.
 * @return
 * NULL
 */
function facetapi_luceneapi_timestamp_convert(&$value, $key, $format) {
  $value = gmdate($format, $value);
}

/**
 * Executes a match query, returns array keyed by document IDs.  This method
 * skips sorting, so it more efficient than calling luceneapi_find.
 *
 * @param $index
 *   A Zend_Search_Lucene_Interface object.
 * @param $query
 *  A Zend_Search_Lucene_Search_Query object.
 * @return
 *   An array keyed by document IDs.
 */
function facetapi_luceneapi_match_query(Zend_Search_Lucene_Interface $index, Zend_Search_Lucene_Search_Query $query) {
  $docs = array();
  try {
    $query = $query->rewrite($index)->optimize($index);
    $query->execute($index);
    $docs = $query->matchedDocs();
  }
  catch (Exception $e) {
    luceneapi_throw_error($e, WATCHDOG_ERROR, 'facetapi_luceneapi');
  }
  return $docs;
}

/**
 * Implementation of hook_apachesolr_prepare_query().
 */
function facetapi_luceneapi_luceneapi_query_alter(Zend_Search_Lucene_Search_Query $query, $module, $type = NULL) {
  facetapi_query_type_hooks_invoke($module, $query);
}

/**
 * Implementation of hook_facetapi_query_TYPE_process().
 */
function facetapi_luceneapi_facetapi_query_term_process(FacetapiAdapter $adapter, array $facet, Zend_Search_Lucene_Search_Query $query) {
  $values = $adapter->getActiveFacets($facet['field alias']);
  if (empty($values)) {
    return;
  }

  try {
    if (!$multiterm = luceneapi_query_get('multiterm')) {
      throw new LuceneAPI_Exception(t(
        'Error instantiating multiterm query.'
      ));
    }

    // Gets the operator.
    $operator = facetapi_setting_get('operator', $adapter->getSearcher(), '', $facet['name']);
    $sign = (FACETAPI_OPERATOR_OR != $operator) ? 'required' : 'neither';

    foreach ($values as $value => $filter_string) {
      $term = luceneapi_term_get((string)$value, $facet['field'], TRUE);
      luceneapi_term_add($multiterm, $term, $sign, TRUE);
    }

    // If there are terms, appends subquery.
    if (count($multiterm->getTerms())) {
      $multiterm->setBoost(LUCENEAPI_IRRELEVANT);
      luceneapi_subquery_add($query, $multiterm, 'required', TRUE);
    }
  }
  catch (LuceneAPI_Exception $e) {
    luceneapi_throw_error($e, WATCHDOG_ERROR, 'facetapi_luceneapi');
  }
}

/**
 * Implementation of hook_facetapi_query_TYPE_process().
 */
function facetapi_luceneapi_facetapi_query_range_process(FacetapiAdapter $adapter, array $facet, Zend_Search_Lucene_Search_Query $query) {
  module_load_include('inc', 'facetapi', 'facetapi.date');
  $values = $adapter->getActiveFacets($facet['field alias']);
  if (empty($values)) {
    return;
  }

  try {
    // Gets the facet's operator.
    if (!$boolean = luceneapi_query_get('boolean')) {
      throw new Exception(t('Error instantiating boolean query.'));
    }
    foreach ($values as $value => $filter_string) {
      $range = explode(' TO ', trim($value, '{[]}'));
      // Adds subquery if ranges were extracted.
      if (2 == count($range)) {
        $range = array_map('strtotime', $range);
        if ($subquery = luceneapi_query_get('range', $range[0], $range[1], FALSE, $facet['field'])) {
          luceneapi_subquery_add($boolean, $subquery, 'required', TRUE);
        }
      }
    }

    // Makes query irrelevant in scoring, appends subquery.
    $boolean->setBoost(LUCENEAPI_IRRELEVANT);
    luceneapi_subquery_add($query, $boolean, 'required');
  }
  catch (Exception $e) {
    luceneapi_throw_error($e, WATCHDOG_ERROR, 'facetapi_luceneapi');
  }
}

/**
 * Implementation of hook_luceneapi_document_alter().
 */
function facetapi_luceneapi_luceneapi_document_alter(Zend_Search_Lucene_Document $doc, $node, $module, $type = NULL) {
  static $fields;
  if ('luceneapi_node' == $module) {

    // Maintains taxonomy ancestry for hierarchical browsing. Parent term counts
    // should also include child terms counts.
    $terms = array();
    if (isset($node->taxonomy) && is_array($node->taxonomy)) {
      foreach ($node->taxonomy as $term) {
        $ancestors = taxonomy_get_parents_all($term->tid);
        foreach ($ancestors as $ancestor) {
          $terms[$ancestor->vid][$ancestor->tid] = $ancestor->tid;
        }
      }
    }

    // Changes the field definition for categories, rebuilds the field's value
    // with all parent and child terms.
    foreach ($terms as $vid => $tids) {
      try {
        $field = $doc->getField('category_'. $vid);
        $field->isStored = FALSE;
        $field->isIndexed = TRUE;
        $field->isTokenized = TRUE;
        $field->value = join(' ', $tids);
      }
      catch (Exception $e) {
        luceneapi_throw_error($e, WATCHDOG_ERROR, 'facetapi_luceneapi');
      }
    }

    // @todo This is nasty. We need a better way to do this.  Unfortunately, we
    // have to wait until this functionality is integrated into the core Search
    // Lucene API module.
    if (NULL === $fields) {
      $fields = array();
      foreach (facetapi_enabled_facets_get($module) as $facet) {
        $fields[] = $facet['field'];
      }
    }
    foreach ($fields as $field) {
      $variable = 'facetapi:termfreqs_cached:'. $module .':::'. $field;
      variable_del($variable);
    }
  }
}

