<?php

/**
 * @file
 * An abstracted facet API that can be used by various search backens.
 */

/**
 * Constant for the "AND" operator.
 */
define('FACETAPI_OPERATOR_AND', 'and');

/**
 * Constant for the "OR" operator.
 */
define('FACETAPI_OPERATOR_OR', 'or');

/**
 * String that represents a time gap of a year between two dates.
 */
define('FACETAPI_DATE_YEAR', 'YEAR');

/**
 * String that represents a time gap of a month between two dates.
 */
define('FACETAPI_DATE_MONTH', 'MONTH');

/**
 * String that represents a time gap of a day between two dates.
 */
define('FACETAPI_DATE_DAY', 'DAY');

/**
 * String that represents a time gap of an hour between two dates.
 */
define('FACETAPI_DATE_HOUR', 'HOUR');

/**
 * String that represents a time gap of a minute between two dates.
 */
define('FACETAPI_DATE_MINUTE', 'MINUTE');

/**
 * String that represents a time gap of a second between two dates.
 */
define('FACETAPI_DATE_SECOND', 'SECOND');

/**
 * Date string for ISO 8601 date formats.
 */
define('FACETAPI_DATE_ISO8601', 'Y-m-d\TH:i:s\Z');

/**
 * Regex pattern for range queries.
 */
define('FACETAPI_REGEX_RANGE', '/^[\[\{](\S+) TO (\S+)[\]\}]$/');

/**
 * Regex pattern for date queries.
 */
define('FACETAPI_REGEX_DATE', '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/');

/**
 * Regex pattern for date ranges.
 */
define('FACETAPI_REGEX_DATE_RANGE', '/^\[('. trim(FACETAPI_REGEX_DATE, '/^$') .') TO ('. trim(FACETAPI_REGEX_DATE, '/^$') .')\]$/');

////
////
//// facetapi_*_load() functions
////
////

/**
 * Returns a searcher module's adapter class.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 *
 * @return
 *   A FacetapiAdapter object, FALSE on errors.
 */
function facetapi_adapter_load($searcher) {
  $adapters = drupal_static(__FUNCTION__, array());
  if (!isset($adapters[$searcher]) || $reset) {
    $definitions = facetapi_get_adapter_info();
    if (isset($definitions[$searcher])) {
      $adapters[$searcher] = new $definitions[$searcher]['class'](
        $searcher, $definitions[$searcher]['type'], $definitions[$searcher]['module']
      );
    }
    else {
      $adapters[$searcher] = FALSE;
    }
  }
  return $adapters[$searcher];
}

/**
 * Returns a realm definition.
 *
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 *
 * @return
 *   An array containing the realm definition, FALSE if $realm_name is not
 *   valid.
 */
function facetapi_realm_load($realm_name) {
  $realms = facetapi_get_realms();
  return (isset($realms[$realm_name])) ? $realms[$realm_name] : FALSE;
}

/**
 * Loads a facet definition.
 *
 * NOTE: Facets aren't statically cached by this function, so avoid situations
 * where this needs to be called repeatedly. Use facetapi_enabled_facets_get()
 * as an alternative.
 *
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 *
 * @return
 *   An array containing the facet definition, FALSE if $facet_name or $searcher
 *   is not valid.
 */
function facetapi_facet_load($facet_name, $searcher) {
  if ($adapter = facetapi_adapter_load($searcher)) {
    $facets = facetapi_get_facets($searcher, $adapter->getType());
    if (isset($facets[$facet_name])) {
      return $facets[$facet_name];
    }
  }
  return FALSE;
}

////
////
//// facetapi_get_*() functions
////
////

/**
 * Invokes hook_facetapi_adapter_info(), returns all adapter definitions.
 *
 * @return
 *   An array of adapter definitions.
 */
function facetapi_get_adapter_info() {
  $adapters = drupal_static(__FUNCTION__);
  if (NULL === $adapters) {

    // Gets adapters from hooks.
    $adapters = array();
    foreach (module_implements('facetapi_adapter_info') as $module) {
      if (($result = module_invoke($module, 'facetapi_adapter_info')) && is_array($result)) {
        foreach ($result as $searcher => $adapter) {
          $adapters[$searcher] = $adapter + array(
            'module' => $module,
            'class' => 'FacetapiAdapter',
            'type' => 'node',
          );
        }
      }
    }

    // Allows modules to alter the adapter definitions.
    drupal_alter('facetapi_adapter_info', $adapters);
  }

  return $adapters;
}

/**
 * Invokes hook_facetapi_realm_info(), returns realm definitions.
 *
 * @return
 *   An array of realm definitions.
 */
function facetapi_get_realm_info() {
  $realm_info = drupal_static(__FUNCTION__);
  if (NULL === $realm_info) {

    // Gets realm info from hooks, merges with defaults.
    $realm_info = module_invoke_all('facetapi_realm_info');
    foreach ($realm_info as $realm_name => $realm) {
      $realm_info[$realm_name] += array(
        'name' => $realm_name,
        'label' => $realm_name,
        'description' => '',
        'default widget' => '',
        'widget requirements' => array(),
        'weight' => 0,
        'sortable' => TRUE,
        'ui' => TRUE,
      );
    }

    // Invokes alter hook, sorts realms by weight.
    drupal_alter('facetapi_realm_info', $realm_info);
    uasort($realm_info, 'drupal_sort_weight');
  }

  return $realm_info;
}

/**
 * Invokes hook_facetapi_facet_info(), returns all defined facets.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $type
 *   A string containing the type of content $searcher indexes.
 *
 * @return
 *   An array containing the facet arrays, FALSE on errors.
 */
function facetapi_get_facet_info($searcher, $type) {
  $facets = array();

  // Gets facets from hooks and the modules the facets are defined in.
  foreach (module_implements('facetapi_facet_info') as $module) {
    $module_facets = module_invoke($module, 'facetapi_facet_info', $searcher, $type);
    foreach ($module_facets as $facet_name => $facet) {

      // Builds array of default values.
      $facets[$facet_name] = $facet + array(
        'name' => $facet_name,
        'label' => $facet_name,
        'description' => '',
        'field' => $facet_name,
        'field alias' => isset($facet['field']) ? $facet['field'] : $facet_name,
        'query type' => 'term',
        'data group' => FALSE,
        'widget requirements' => array(),
        'default widgets' => array(),
        'weight' => 0,
        'map callback' => FALSE,
        'hierarchy callback' => FALSE,
        'values callback' => FALSE,
        'min callback' => FALSE,
        'max callback' => FALSE,
        'file' => '',
        'file path' => drupal_get_path('module', $module),
        'default sorts' => array(
          array('active', SORT_DESC),
          array('count', SORT_DESC),
          array('display', SORT_ASC),
        ),
      );

      // Checks whether facet is flat or hierarchical, adds to requirements.
      if (!$facets[$facet_name]['hierarchy callback']) {
        $facets[$facet_name]['widget requirements'][] = 'flat';
      }
      else {
        $facets[$facet_name]['widget requirements'][] = 'hierarchical';
      }
    }

    // Invokes alter hook to allow modules to modify facet definitions.
    drupal_alter('facetapi_facet_info', $facets, $searcher, $type);
  }

  // Sorts facets by weight, returns facets.
  uasort($facets, 'drupal_sort_weight');
  return $facets;
}

/**
 * Returns settings associated with a realm.
 *
 * @param $searcher
 *   A string
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 * @param $facet_name
 *   A string containing the machine readable name of the facet.
 * @return
 *   An object containing the realm settigns, NULL if there are no settings.
 */
function facetapi_get_facet_settings($searcher, $realm_name, $facet_name) {
  ctools_include('export');
  $name = $searcher . ':' . $realm_name . ':' . $facet_name;
  return ctools_export_crud_load('facetapi', $name);
}

////
////
//// Facet API hook implementations
////
////

/**
 * Implements hook_facetapi_realm_info().
 */
function facetapi_facetapi_realm_info() {
  $realms = array();

  // Displays each facet in a separate block.
  $realms['block'] = array(
    'label' => t('Blocks'),
    'weight' => -10,
    'sortable' => FALSE,
    'default widget' => 'facetapi_links',
    'widget requirements' => array('list'),
    'description' => t(
      'The <em>Blocks</em> realm displays each facet in a separate <a href="@block-page">block</a>. Users are able to refine their searches in a drill-down fassion similar to the Apache Solr Search Integration module\'s faceted search implementation.',
      array('@block-page' => url('admin/build/block/list', array('query' => array('destination' => $_GET['q']))))
    ),
  );

  // Displays facets in a fieldset below the search form.
  $realms['fieldset'] = array(
    'label' => t('Fieldset'),
    'weight' => -5,
    'default widget' => 'facetapi_textfield',
    'widget requirements' => array('form'),
    'description' => t('The <em>Fieldset</em> realm displays facets as form elements in a fieldset below the search form that is similar in appearance to the core Search module\'s <em>Advanced search</em> fieldset.'),
  );

  return $realms;
}

/**
 * Implements hook_facetapi_facet_info().
 */
function facetapi_facetapi_facet_info($searcher, $type) {
  $facets = array();
  if ('node' == $type) {

    $facets['type'] = array(
      'label' => t('Content type'),
      'description'=> t('Filter by content type.'),
      'map callback'=> 'facetapi_callback_type_map',
      'values callback' => 'facetapi_callback_type_values',
      'widget requirements'=> array('has default values'),
      'default widgets' => array('facetapi_checkboxes'),
      'file'=> 'facetapi.callbacks.inc',
    );

    $facets['author'] = array(
      'label' => t('Author'),
      'description' => t('Filter by author.'),
      'field' => 'uid',
      'data group' => 'user',
      'widget requirements' => array('has default values'),
      'map callback' => 'facetapi_callback_uid_map',
      'values callback' => 'facetapi_callback_user_values',
      'file' => 'facetapi.callbacks.inc',
    );

    $facets['language'] = array(
      'label' => t('Language'),
      'description' => t('Filter by language.'),
      'widget requirements' => array('has default values'),
      'default widgets' => array('facetapi_checkboxes'),
      'map callback' => 'facetapi_callback_language_map',
      'values callback' => 'facetapi_callback_language_values',
      'file' => 'facetapi.callbacks.inc',
    );

    $facets['created'] = array(
      'label' => t('Post date'),
      'description' => t('Filter by the date the node was posted.'),
      'widget requirements' => array('date'),
      'query type' => 'date',
      'map callback' => 'facetapi_callback_date_map',
      'min callback' => 'facetapi_callback_min_date',
      'max callback' => 'facetapi_callback_max_date',
      'file' => 'facetapi.callbacks.inc',
      'default sorts' => array(
        array('active', SORT_DESC),
        array('indexed', SORT_ASC),
      ),
    );

    $facets['changed'] = array(
      'label' => t('Updated date'),
      'description' => t('Filter by the date the node was last modified.'),
      'widget requirements' => array('date'),
      'query type' => 'date',
      'map callback' => 'facetapi_callback_date_map',
      'min callback' => 'facetapi_callback_min_date',
      'max callback' => 'facetapi_callback_max_date',
      'file' => 'facetapi.callbacks.inc',
      'default sorts' => array(
        array('active', SORT_DESC),
        array('indexed', SORT_ASC),
      ),
    );
  }

  return $facets;
}
