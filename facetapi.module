<?php
// $Id$

/**
 * @file
 * An abstracted facet API that can be used by various search backens.
 */

/**
 * Constant for the "AND" operator.
 */
define('FACETAPI_OPERATOR_AND', 'and');

/**
 * Constant for the "OR" operator.
 */
define('FACETAPI_OPERATOR_OR', 'or');

/**
 * String that represents a time gap of a year between two dates.
 */
define('FACETAPI_DATE_YEAR', 'YEAR');

/**
 * String that represents a time gap of a month between two dates.
 */
define('FACETAPI_DATE_MONTH', 'MONTH');

/**
 * String that represents a time gap of a day between two dates.
 */
define('FACETAPI_DATE_DAY', 'DAY');

/**
 * String that represents a time gap of an hour between two dates.
 */
define('FACETAPI_DATE_HOUR', 'HOUR');

/**
 * String that represents a time gap of a minute between two dates.
 */
define('FACETAPI_DATE_MINUTE', 'MINUTE');

/**
 * String that represents a time gap of a second between two dates.
 */
define('FACETAPI_DATE_SECOND', 'SECOND');

/**
 * Date string for ISO 8601 date formats.
 */
define('FACETAPI_DATE_ISO8601', 'Y-m-d\TH:i:s\Z');

/**
 * Implementation of hook_menu().
 */
function facetapi_menu() {
  $items = array();

  // Configuration page for a facet.
  $items['admin/settings/%facetapi_adapter/facetapi/%facetapi_realm/%facetapi_facet'] = array(
    'title' => 'Facet configuration settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('facetapi_facet_settings_form', 2, 4, 5),
    'load arguments' => array(2),
    'access arguments' => array('administer search'),
    'type' => MENU_CALLBACK,
    'file' => 'facetapi.admin.inc',
  );

  // Default tab for the facet configuration pages.
  $items['admin/settings/%facetapi_adapter/facetapi/%facetapi_realm/%facetapi_facet/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'load arguments' => array(2),
    'weight' => -40,
  );

  /*
  // Import page for a facet.
  $items['admin/settings/%facetapi_adapter/facetapi/%facetapi_realm/%facetapi_facet/import'] = array(
    'title' => 'Import',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('facetapi_import_form', 2, 4, 5),
    'load arguments' => array(2),
    'access arguments' => array('administer search'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'facetapi.export.inc',
    'weight' => -30,
  );

  // Export page for a facet.
  $items['admin/settings/%facetapi_adapter/facetapi/%facetapi_realm/%facetapi_facet/export'] = array(
    'title' => 'Export',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('facetapi_export_form', 2, 4, 5),
    'load arguments' => array(2),
    'access arguments' => array('administer search'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'facetapi.export.inc',
    'weight' => -20,
  );
  */

  return $items;
}

/**
 * Returns a searcher module's adapter class.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $reset
 *   A boolean flagging whether the static should be reset.
 *
 * @return
 *   A FacetapiAdapter object, FALSE on errors.
 */
function facetapi_adapter_load($searcher, $reset = FALSE) {
  static $adapters = array();

  // Due to the "load arguments" parameter defined in some menu items, we want
  // to ignore non-booleans so that the static isn't reset whenever the menu
  // system calls this function.
  if (!is_bool($reset)) {
    $reset = FALSE;
  }

  // Ensures only one instance of this class exists.
  if (!isset($adapters[$searcher]) || $reset) {
    $definitions = facetapi_adapter_definitions_get();
    if (isset($definitions[$searcher]) && facetapi_file_include($definitions[$searcher])) {
      $adapters[$searcher] = new $definitions[$searcher]['class'](
        $searcher, $definitions[$searcher]['type'], $definitions[$searcher]['module']
      );
    }
    else {
      $adapters[$searcher] = FALSE;
    }
  }

  return $adapters[$searcher];
}

/**
 * Returns a single realm definition.
 *
 * @param $realm_name
 *   A string contaiing the machine readable name of the realm.
 *
 * @return
 *   An array containing the realm definition, FALSE if $realm_name is not
 *   valid.
 */
function facetapi_realm_load($realm_name) {
  $realms = facetapi_realms_get();
  return (isset($realms[$realm_name])) ? $realms[$realm_name] : FALSE;
}

/**
 * Loads a single facet definition.
 *
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 *
 * @return
 *   An array containing the facet definition, FALSE if $facet_name or $searcher
 *   is not valid.
 */
function facetapi_facet_load($facet_name, $searcher) {
  if ($adapter = facetapi_adapter_load($searcher)) {
    $facets = facetapi_facets_get($searcher, $adapter->getType());
    if (isset($facets[$facet_name])) {
      return $facets[$facet_name];
    }
  }
  return FALSE;
}

/**
 * Implementation of hook_theme().
 */
function facetapi_theme() {
  return array(
    'facetapi_admin_settings_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'facetapi.admin.inc',
    ),
    'facetapi_block' => array(
      'arguments' => array('links' => NULL, 'title' => NULL, 'attributes' => array()),
      'file' => 'facetapi.theme.inc',
    ),
    'facetapi_block_title' => array(
      'arguments' => array('title' => NULL),
      'file' => 'facetapi.theme.inc',
    ),
    'facetapi_count' => array(
      'arguments' => array('count' => NULL),
      'file' => 'facetapi.theme.inc',
    ),
    'facetapi_link' => array(
      'arguments' => array('text' => NULL, 'path' => NULL, 'options' => array()),
      'file' => 'facetapi.theme.inc',
    ),
    'facetapi_link_inactive' => array(
      'arguments' => array('text' => NULL, 'path' => NULL, 'options' => array(), 'count' => 0),
      'file' => 'facetapi.theme.inc',
    ),
    'facetapi_link_active' => array(
      'arguments' => array('text' => NULL, 'path' => NULL, 'options' => array()),
      'file' => 'facetapi.theme.inc',
    ),
    'facetapi_markup' => array(
      'arguments' => array('title' => NULL, 'markup' => NULL, 'type' => NULL),
      'template' => 'facetapi-markup',
    ),
  );
}

/**
 * Process variables for block.tpl.php.
 *
 * Converts the md5() hash back to something human readable.
 */
function facetapi_preprocess_block(&$vars) {
  if ('facetapi' == $vars['block']->module) {
    $map = facetapi_delta_map_get();
    if (isset($map[$vars['block']->delta])) {
      $vars['block']->delta = str_replace(':', '-', $map[$vars['block']->delta]);
    }
  }
}

/**
 * Helper function to execute a map query. A map query is useful for converting
 * unique identifiers to human readable values, for example a uid to username.
 *
 * @param $sql
 *   A string containing the SQL query mapping the ID to another value. The
 *   query must select the "id" and "name" fields.
 * @param $ids
 *   An array containing the IDs being mapped.
 * @param $type
 *   The Schema API type of the ID field (e.g. 'int', 'text', or 'varchar').
 *
 * @return
 *   An array of mapped IDs.
 */
function facetapi_map_query($sql, array $ids, $type = 'int') {
  $map = array();
  if (!empty($ids)) {
    $sql = str_replace('!placeholders', db_placeholders($ids, $type), $sql);
    if ($result = db_query($sql, $ids)) {
      while ($record = db_fetch_object($result)) {
        $map[$record->id] = $record->name;
      }
    }
  }
  return $map;
}

/**
 * Identical to the l() function, except the "active" class is not automatically
 * set. This is useful for generating links that are displayed on the search
 * page and link back to the search page. If we used l(), all facet links would
 * be "active" since they link back to the page on which they are being
 * displayed.
 *
 * @param $text
 *   A string containing the text to be enclosed with the anchor tag.
 * @param $path
 *   A string containing the Drupal path being linked to. Can be an external or
 *   internal URL.
 * @param $options
 *   An associative array of additional options.
 *
 * @return
 *   A string containing the anchor link.
 *
 * @see l()
 */
function facetapi_l($text, $path, array $options = array()) {
  global $language;
  $options += array(
    'attributes' => array(),
    'html' => FALSE,
  );
  if (isset($options['attributes']['title']) && FALSE !== strpos($options['attributes']['title'], '<')) {
    $options['attributes']['title'] = strip_tags($options['attributes']['title']);
  }
  return sprintf(
    '<a href="%s"%s>%s</a>',
    check_url(url($path, $options)),
    drupal_attributes($options['attributes']),
    ($options['html'] ? $text : check_plain($text))
  );
}

/**
 * Encodes search keys before submit to prevent plus signs from being converted
 * to spaces.
 *
 * @param $keys
 *   A string containing the search keys.
 *
 * @return
 *   A string with special characters encoded.
 */
function facetapi_keys_encode($keys) {
  return str_replace('+', '%2B', $keys);
}

/**
 * Invokes hook_facetapi_adapters(), returns all adapter definitions.
 *
 * @param $reset
 *   A boolean flagging whether the static should be reset.
 *
 * @return
 *   An array of adapter definitions.
 */
function facetapi_adapter_definitions_get($reset = FALSE) {
  static $adapters;
  if (NULL === $adapters || $reset) {
    module_load_include('inc', 'facetapi', 'facetapi.adapter');

    // Gets adapters from hooks.
    $adapters = array();
    foreach (module_implements('facetapi_adapters') as $module) {
      if (($result = module_invoke($module, 'facetapi_adapters')) && is_array($result)) {
        foreach ($result as $searcher => $adapter) {

          // Builds array of default values.
          $defaults = array(
            'module' => $module,
            'class' => 'FacetapiAdapter',
            'type' => 'node',
            'file' => '',
            'file path' => drupal_get_path('module', $module),
          );

          // Merges adapter definition into defaults, appends relam to list.
          $adapters[$searcher] = array_merge($defaults, $adapter);
        }
      }
    }

    // Allows modules to alter the adapter definitions.
    drupal_alter('facetapi_adapters', $adapters);
  }
  return $adapters;
}

/**
 * Invokes hook_facetapi_realms(), returns realm definitions.
 *
 * @param $reset
 *   A boolean flagging whether the static should be reset.
 *
 * @return
 *   An array of realm definitions.
 */
function facetapi_realms_get($reset = FALSE) {
  static $realms;
  if (NULL === $realms || $reset) {
    $realms = array();

    // Gets realms from hooks and the modules they are defined in.
    foreach (module_implements('facetapi_realms') as $module) {
      $module_realms = module_invoke($module, 'facetapi_realms');
      if (!is_array($module_realms)) {
        // @todo Call watchdog() or drupal_set_message()???
        continue;
      }

      // Iterates over the module's realms, applies defaults.
      foreach ($module_realms as $realm_name => $realm) {

        // Builds array of default values.
        $defaults = array(
          'name' => $realm_name,
          'title' => $realm_name,
          'description' => '',
          'weight' => 0,
          'sortable' => TRUE,
          'module' => $module,
          'callback' => $module .'_realm_'. $realm_name .'_render',
          'file' => '',
          'file path' => drupal_get_path('module', $module),
        );

        // Merges realm definition into defaults, appends relam to list.
        $realms[$realm_name] = array_merge($defaults, $realm);
      }
    }

    // Invokes alter hook, sorts realms by weight, caches realm data.
    drupal_alter('facetapi_realms', $realms);
    uasort($realms, 'facetapi_sort_weight');
  }

  // Returns realms.
  return $realms;
}

/**
 * Invokes hook_facetapi_facets(), returns all defined facets.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $type
 *   A string containing the type of content $searcher indexes.
 *
 * @return
 *   An array containing the facet arrays, FALSE on errors.
 */
function facetapi_facets_get($searcher, $type) {
  $facets = array();

  // Gets facets from hooks and the modules the facets are defined in.
  foreach (module_implements('facetapi_facets') as $module) {
    $module_facets = module_invoke($module, 'facetapi_facets', $searcher, $type);
    if (!is_array($module_facets)) {
      // @todo Call watchdog() or drupal_set_message()???
      continue;
    }

    // Sets facet definition defaults.
    foreach ($module_facets as $facet_name => $facet) {

      // Builds array of default values.
      $defaults = array(
        'name' => $facet_name,
        'title' => $facet_name,
        'description' => '',
        'field' => $facet_name,
        'field alias' => isset($facet['field']) ? $facet['field'] : $facet_name,
        'query type' => 'term',
        'fetch type' => isset($facet['query type']) ? $facet['query type'] : 'term',
        'form type' => 'checkboxes',
        'weight' => 0,
        'map callback' => FALSE,
        'hierarchy callback' => FALSE,
        'values callback' => FALSE,
        'default range callback' => FALSE,
        'file' => '',
        'file path' => drupal_get_path('module', $module),
      );

      // Merges facet definition into defaults.
      $facets[$facet_name] = array_merge($defaults, $facet);
    }

    // Invokes alter hook to allow modules to modify facet definitions.
    drupal_alter('facetapi_facets', $facets, $searcher, $type);
  }

  // Sorts facets by weight, returns facets.
  uasort($facets, 'facetapi_sort_weight');
  return $facets;
}

/**
 * Returns facets enabled in a given realm.  If the realm name is NULL, all
 * facets that are enabled in at least one realm will be returned.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the realm.  Passing NULL will check all realms and
 *   return the facet if it is enabled in at least one realm.
 * @param $reset
 *   A boolean flagging whether the static should be reset.
 *
 * @return
 *   An array of facets.
 */
function facetapi_enabled_facets_get($searcher, $realm_name = NULL, $reset = FALSE) {
  static $facets = array();

  // Formats cache ID based on $searcher, $realm_name, and language.
  global $language;
  $cid = 'facetapi:facets:'. $searcher;
  if (NULL !== $realm_name) {
    $cid .= ':'. $realm_name;
  }
  $cid .= ':'. $language->language;

  // Checks if the facets have already been loaded.
  if (!isset($facets[$cid]) || $reset) {

    // Tests if data is cached, otherwise calculates enabled facets.
    if ($data = cache_get($cid, 'cache')) {
      $facets[$cid] = $data->data;
    }
    else {

      // Gets the searcher module's adapter, returns an empty array if $searcher
      // does not have an adapter.
      $facets[$cid] = array();
      if (!$adapter = facetapi_adapter_load($searcher)) {
        return $facets[$cid];
      }

      // Normalizes realm name(s) to an array, adds weights if realm was passed.
      $realm_names = (NULL === $realm_name) ? array_keys(facetapi_realms_get()) : array($realm_name);

      // Finds enabled facets for each realm.
      // NOTE: We use $_realm_name for the variable name because $realm_name
      // cannot be overwritten since its value checked later in the code.
      $enabled_facets = array();
      foreach ($realm_names as $_realm_name) {
        $enabled_facets = array_merge($enabled_facets, array_filter(
          (array)facetapi_setting_get('facet_status', $searcher, $_realm_name)
        ));
      }

      // Gets full facet definitions for all facets, strips out facets that are
      // not in $enabled_facets using the array_intersect_key() function.
      if ($all_facets = facetapi_facets_get($searcher, $adapter->getType())) {
        $facets[$cid] = array_intersect_key($all_facets, $enabled_facets);
        if (NULL !== $realm_name) {
          facetapi_facets_sort($facets[$cid], $searcher, $realm_name);
        }
        cache_set($cid, $facets[$cid], 'cache', CACHE_TEMPORARY);
      }
    }

    // Loads all include files.
    foreach ($facets[$cid] as $facet) {
      facetapi_file_include($facet);
    }
  }

  return $facets[$cid];
}

/**
 * Invokes hook_facetapi_widgets(), returns all defined widgets.
 *
 * @return
 *   An associative array of widget definitions keyed by widget name.
 */
function facetapi_widgets_get() {
  static $widgets;
  if (NULL === $widgets) {
    $widgets = module_invoke_all('facetapi_widgets');
    drupal_alter('facetapi_widgets', $widgets);
  }
  return $widgets;
}

/**
 * Tests whether a single facet is enabled in a given realm.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 * @param $facet_name
 *   A string containing the machine readable name of the facet.
 *
 * @return
 *   A boolean flagging whether the facet is enabled in the passed realm.
 */
function facetapi_facet_enabled($searcher, $realm_name, $facet_name) {
  $enabled_facets = facetapi_enabled_facets_get($searcher, $realm_name, $facet_name);
  return isset($enabled_facets[$facet_name]);
}

/**
 * Enables a facet in the passed realm(s).
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the machine readable name of the realm. Passing NULL
 *   will enable the facet in all realms.
 * @param $facet_name
 */
function facetapi_facet_enable($searcher, $realm_name, $facet_name) {
  facetapi_facet_status_set($searcher, $realm_name, $facet_name, TRUE);
}

/**
 * Disables a facet in the passed realm(s).
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the machine readable name of the realm. Passing NULL
 *   will disable the facet in all realms.
 * @param $facet_name
 *   A string containing the machine readable name of the facet.
 */
function facetapi_facet_disable($searcher, $realm_name, $facet_name) {
  facetapi_facet_status_set($searcher, $realm_name, $facet_name, FALSE);
}

/**
 * Sets the enabled/disabled status of a facet. It is recommended that the
 * facetapi_facet_enable() and facetapi_facet_disable() functions are used in
 * favor of calling this function directly.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the machine readable name of the realm. Passing NULL
 *   will take action on the facet in all realms.
 * @param $facet_name
 *   A string containing the machine readable name of the facet.
 * @param $enabled
 *   A boolean flagging whether the facet is enabled.
 */
function facetapi_facet_status_set($searcher, $realm_name, $facet_name, $enabled) {
  $realm_names = (NULL === $realm_name) ? array_keys(facetapi_realms_get()) : array($realm_name);
  foreach ($realm_names as $realm_name) {

    // Gets current variable, toggles status for the facet, sets the variable.
    $facets = (array)facetapi_setting_get('facet_status', $searcher, $realm_name);
    $facets[$facet_name] = ($enabled) ? $facet_name : 0;
    facetapi_setting_set('facet_status', $facets, $searcher, $realm_name);

    // Clears the facet status cache.
    $cid = 'facetapi:facets:'. $searcher .':';
    if (NULL !== $realm_name) {
      $cid .= $realm_name .':';
    }
    cache_clear_all($cid, 'cache', TRUE);
  }
}

/**
 * Returns a Facet API configuration setting.
 *
 * @param $setting
 *   A string containing the facet configuration setting name.
 * @param ...
 *   Additional arguments that define what the setting applies to. For example,
 *   optionally pass the machine readable name of the searcher, realm, and facet
 *   in that order to add granularity the setting applies to.
 *
 * @reutrn
 *   A mixed value containing the setting.
 */
function facetapi_setting_get($setting) {
  $args = func_get_args();
  $variable = join(':', array_merge(array('facetapi'), $args));
  return variable_get($variable, NULL);
}

/**
 * Sets a Facet API configuration setting.
 *
 * @param $setting
 *   A string containing the facet configuration setting name.
 * @param $value
 *   A mixed value containing the setting value.
 * @param ...
 *   Additional arguments that define which item the setting applies to. For
 *   example, optionally pass the machine readable name of the searcher, realm,
 *   and facet in that order to add granularity the setting applies to.
 *
 * @reutrn
 *   NULL
 */
function facetapi_setting_set($setting, $value) {
  $args = func_get_args();
  unset($args[1]);
  $variable = join(':', array_merge(array('facetapi'), $args));
  variable_set($variable, $value);
}

/**
 * Invokes query type callbacks for all facets.
 *
 * Query type hooks are generally used to process facet data and apply filters
 * to the query for the selectd items. The query type is set in the facet
 * definition, and the adapter module's hook_facetapi_query_TYPE_process()
 * implementation is invoked for each facet being rendered by the adapter.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param &$data
 *   A mixed value containing any data that needs to be altered.  For example,
 *   this may be the "params" array for Apache Solr or the query object for
 *   Search Lucene API.
 * @param ...
 *   Any additional parameters passed to the hook.
 */
function facetapi_query_type_hooks_invoke($searcher, &$data) {
  if ($adapter = facetapi_adapter_load($searcher)) {
    $facets = facetapi_enabled_facets_get($searcher);
    foreach ($facets as $facet) {
      $hook = 'facetapi_query_'. $facet['query type'] .'_process';
      if (module_hook($adapter->getModule(), $hook)) {
        $function = $adapter->getModule() .'_'. $hook;
        $args = func_get_args();
        $params = array_merge(array($adapter, $facet, &$data), array_slice($args, 2));
        call_user_func_array($function, $params);
      }
    }
  }
}

/**
 * Renders a facet realm, in other words converts the facet values to some
 * normalized value.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 *
 * @return
 *   A structured array containing the "rendered" facets.
 */
function facetapi_realm_render($searcher, $realm_name) {
  $rendered = array();

  // Gets all defined realms, makes sure the passed realm is valid.
  $realms = facetapi_realms_get();
  if (isset($realms[$realm_name])) {

    // Gets facets enabled in the realm, includes file and invokes callback.
    $facets = facetapi_enabled_facets_get($searcher, $realm_name);
    if (!empty($facets) && facetapi_file_include($realms[$realm_name])) {
      $adapter = facetapi_adapter_load($searcher);
      $type = $adapter->getType();

      // Adds JS, renders  facets, allows modules to alter the rendered facets.
      drupal_add_js(drupal_get_path('module', 'facetapi') .'/js/facetapi.js');
      $rendered = call_user_func($realms[$realm_name]['callback'], $adapter, $realm_name, $facets);
      drupal_alter('facetapi_postrender', $rendered, $searcher, $type, $realm_name);
    }
  }

  // Returns the rendered facet realm.
  return $rendered;
}

/**
 * Loads a file in a facet or realm definition.
 *
 * @param $definition
 *   An array containing the full facet / realm definitions.
 *
 * @return
 *   A boolean, returns FALSE only when the specified file fails to load.
 */
function facetapi_file_include(array $definition) {
  if (!empty($definition['file']) && !empty($definition['file path'])) {
    $filename = $definition['file path'] .'/'. $definition['file'];
    if (!file_exists($filename)) {
      return FALSE;
    }
    require_once $filename;
  }
  return TRUE;
}

/**
 * Adds weights to each facet, sorts the facet list.
 *
 * @param &$facets
 *   A reference to the array of facets being sorted.
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 */
function facetapi_facets_sort(array &$facets, $searcher, $realm_name) {
  foreach ($facets as $facet_name => &$facet) {
    $facet['weight'] = (int)facetapi_setting_get('facet_weight', $searcher, $realm_name, $facet_name);
  }
  uasort($facets, 'facetapi_sort_weight');
}

/**
 * Useful as a uasort() callback to sort structured arrays by weight. Loose
 * backport of the D7 drupal_sort_weight() function.
 */
function facetapi_sort_weight(array $a, array $b) {
  $a_weight = (isset($a['weight'])) ? $a['weight'] : 0;
  $b_weight = (isset($b['weight'])) ? $b['weight'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}

/**
 * Sorts by whether or not a facet is "active", usually used in conjunction
 * with the other usort() callbacks.
 */
function facetapi_sort_active(array $a, array $b) {
  $a_active = (isset($a['active'])) ? $a['active'] : 0;
  $b_active = (isset($b['active'])) ? $b['active'] : 0;
  if ($a_active == $b_active) {
    return 0;
  }
  return ($a_active > $b_active) ? -1 : 1;
}

/**
 * Useful as a uasort() callback to sort structured arrays by count.  If the
 * weights are equal, sorts by text.
 *
 * @see facetapi_sort_text()
 * @see facetapi_sort_active()
 */
function facetapi_sort_count(array $a, array $b) {
  $a_count = (isset($a['count'])) ? $a['count'] : 0;
  $b_count = (isset($b['count'])) ? $b['count'] : 0;
  if ($a_count == $b_count) {
    return facetapi_sort_text($a, $b);
  }
  // NOTE: Sorts in reverse order, starting with highest count.
  return ($a_count > $b_count) ? -1 : 1;
}

/**
 * Useful as a uasort() callback to sort structured arrays by text.
 */
function facetapi_sort_text(array $a, array $b) {
  if ($active_sort = facetapi_sort_active($a, $b)) {
    return $active_sort;
  }
  $a_count = (isset($a['text'])) ? $a['text'] : '';
  $b_count = (isset($b['text'])) ? $b['text'] : '';
  return strcasecmp($a['text'], $b['text']);
}

/**
 * Useful as a uasort() callback to reverse sort structured arrays by title.
 */
function facetapi_rsort_text(array $a, array $b) {
  return -1 * facetapi_sort_text($a, $b);
}

/**
 * Tests whether a vocabulary is hierarchical.
 *
 * @param $vid
 *   An integer containing the vocabulary ID.
 *
 * @return
 *   A boolean flagging whether the vocabulary is hierarchical.
 */
function facetapi_vocabulary_hierarchical($vid) {
  $hierarchical = FALSE;
  if (module_exists('taxonomy')) {
    $vocabularies = taxonomy_get_vocabularies();
    if (isset($vocabularies[$vid])) {
      // @todo Make this a setting in the facet's configuration page.
      // $force_flat = variable_get('apachesolr_search_force_flat_vocabularies', array());
      if ($vocabularies[$vid]->hierarchy != 2 && $vocabularies[$vid]->tags != 1) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Processes hierarchical relationships for facet items.
 *
 * @param &$facet_items
 *   An array containing the facet items being processed into a hierarchical
 *   structure.
 * @param $facet
 *   An array containing the full facet definition.
 *
 * @return
 *   NULL
 */
function facetapi_hierarchy_process(array &$facet_items, array $facet) {

  // Builds the hierarchy information if the hierarchy callback is defined.
  if (!empty($facet['hierarchy callback']) && !empty($facet_items)) {
    $parents = $facet['hierarchy callback'](array_keys($facet_items));
    foreach ($parents as $value => $parents) {
      foreach ($parents as $parent) {
        if (isset($facet_items[$parent])) {
          if (isset($facet_items[$value])) {
            // Use a reference so we see the updated data.
            $facet_items[$parent]['children'][$value] = &$facet_items[$value];
            $facet_items[$value]['parents'][$parent] = $parent;
          }
        }
      }
    }
  }

  // Tests whether parents have an active child.
  // @todo: Can we make this more efficient?
  do {
    $active = 0;
    foreach ($facet_items as $value => $item) {
      if ($item['active'] && !empty($item['parents'])) {
        // @todo Can we render facets with multiple parents? Core taxonomy
        // form cannot, so we will need a check here.
        foreach ($item['parents'] as $parent) {
          if (!$facet_items[$parent]['active']) {
            $active = $facet_items[$parent]['active'] = 1;
          }
        }
      }
    }
  } while ($active);

  // Strips children whose parents are inactive.
  $facet_items = array_filter($facet_items, 'facetapi_inactive_parent_filter');
}

/**
 * Callback for array_filter() that strips out all children whose parents are
 * inactive.
 *
 * @param $item
 *   An array containing the facet item.
 *
 * @return
 *   A boolean flagging whether the value should remain in the array.
 */
function facetapi_inactive_parent_filter(array $item) {
  return empty($item['parents']);
}

/**
 * Helper function to convert dates from Unix timestamps into ISO 8601 format.
 *
 * @param $timestamp
 *   An integer containing the Unix timestamp being converted.
 * @param $gap
 *   A string containing the gap, see FACETAPI_DATE_* constants for valid
 *   values. Defaults to FACETAPI_DATE_SECOND.
 *
 * @return
 *   A string containing the date in ISO 8601 format,
 */
function facetapi_isodate($timestamp, $gap = FACETAPI_DATE_SECOND) {
  switch ($gap) {
    case FACETAPI_DATE_SECOND:
      $format = FACETAPI_DATE_ISO8601;
      break;

    case FACETAPI_DATE_MINUTE:
      $format = 'Y-m-d\TH:i:00\Z';
      break;

    case FACETAPI_DATE_HOUR:
      $format = 'Y-m-d\TH:00:00\Z';
      break;

    case FACETAPI_DATE_DAY:
      $format = 'Y-m-d\T00:00:00\Z';
      break;

    case FACETAPI_DATE_MONTH:
      $format = 'Y-m-01\T00:00:00\Z';
      break;

    case FACETAPI_DATE_YEAR:
      $format = 'Y-01-01\T00:00:00\Z';
      break;

    default:
      $format = FACETAPI_DATE_ISO8601;
      break;
  }
  return gmdate($format, $timestamp);
}

/**
 * Return a date gap one increment smaller than the one passed.
 *
 * @param $gap
 *   A string containing the gap, see FACETAPI_DATE_* constants for valid
 *   values.
 * @param $min_gap
 *   A string containing the the minimum gap that can be returned, defaults to
 *   FACETAPI_DATE_SECOND. This is useful for defining the smallest increment
 *   that can be used in a date drilldown.
 *
 * @return
 *   A string containing the smaller date gap, NULL if there is no smaller gap.
 *   See FACETAPI_DATE_* constants for valid values.
 */
function facetapi_next_date_gap_get($gap, $min_gap = FACETAPI_DATE_SECOND) {
  // Array of numbers used to determine whether the next gap is smaller than
  // the minimum gap allowed in the drilldown.
  $gap_numbers = array(
    FACETAPI_DATE_YEAR => 6,
    FACETAPI_DATE_MONTH => 5,
    FACETAPI_DATE_DAY => 4,
    FACETAPI_DATE_HOUR => 3,
    FACETAPI_DATE_MINUTE => 2,
    FACETAPI_DATE_SECOND => 1,
  );

  // Gets gap numbers for both the gap and minimum gap, checks if the next gap
  // is within the limit set by the $min_gap parameter.
  $gap_num = isset($gap_numbers[$gap]) ? $gap_numbers[$gap] : 6;
  $min_num = isset($gap_numbers[$min_gap]) ? $gap_numbers[$min_gap] : 1;

  if ($gap_num > $min_num) {
    return array_search($gap_num - 1, $gap_numbers);
  }
  else {
    return $min_gap;
  }
}

/**
 * Determines the best search gap to use for an arbitrary date range.
 *
 * Generally, we use the maximum gap that fits between the start and end date.
 * If they are more than a year apart, 1 year; if they are more than a month
 * apart, 1 month; etc.
 *
 * This function uses Unix timestamps for its computation and so is not useful
 * for dates outside that range.
 *
 * @param $start_date
 *   A string containing the start date as an ISO date string.
 * @param $end_date
 *   A string containing the end date as an ISO date string.
 *
 * @return
 *   A string containing the gap, see FACETAPI_DATE_* constants for valid
 *   values. Returns FALSE of either of the dates cannot be converted to a
 *   timestamp.
 */
function facetapi_timestamp_gap_get($start_time, $end_time) {
  $time_diff = $end_time - $start_time;
  switch (TRUE) {
    // NOTE: 86400365 == 60 * 60 * 24 * 365
    case ($time_diff >= 86400365):
      return FACETAPI_DATE_YEAR;

    case (date('Ym', $start_time) != date('Ym', $end_time)):
      return FACETAPI_DATE_MONTH;

    case ($time_diff >= 86400):
      return FACETAPI_DATE_DAY;

    case ($time_diff >= 3600):
      return FACETAPI_DATE_HOUR;

    case ($time_diff >= 60):
      return FACETAPI_DATE_MINUTE;

    default:
      return FACETAPI_DATE_SECOND;
  }
}

/**
 * Converts ISO date strings to Unix timestamps, passes values to the
 * facetapi_timestamp_gap_get() function to calculate the gap.
 *
 * @param $start_date
 *   A string containing the start date as an ISO date string.
 * @param $end_date
 *   A string containing the end date as an ISO date string.
 *
 * @return
 *   A string containing the gap, see FACETAPI_DATE_* constants for valid
 *   values. Returns FALSE of either of the dates cannot be converted to a
 *   timestamp.
 *
 * @see facetapi_timestamp_gap_get()
 */
function facetapi_date_gap_get($start_date, $end_date) {
  $range = array(strtotime($start_date), strtotime($end_date));
  // NOTE: Previous to PHP 5.1.0, this strtotime() returns -1 on failure.
  if (!in_array(FALSE, $range, TRUE) && !in_array(-1, $range)) {
    return facetapi_timestamp_gap_get($range[0], $range[1]);
  }
  return FALSE;
}

/**
 * Returns a formatted date based on the passed timestamp and gap.
 *
 * This function assumes that gaps less than one day will be displayed in a
 * search context in which a larger containing gap including a day is already
 * displayed.  So, HOUR, MINUTE, and SECOND gaps only display time information,
 * without date.
 *
 * @param $timestamp
 *   An integer containing the Unix timestamp.
 * @param $gap
 *   A string containing the gap, see FACETAPI_DATE_* constants for valid
 *   values, defaults to YEAR.
 *
 * @return
 *   A gap-appropriate display date used in the facet link.
 */
function facetapi_timestamp_format($timestamp, $gap = FACETAPI_DATE_YEAR) {
  switch ($gap) {
    case FACETAPI_DATE_MONTH:
      return format_date($timestamp, 'custom', 'F Y', 0);

    case FACETAPI_DATE_DAY:
      return format_date($timestamp, 'custom', 'F j, Y', 0);

    case FACETAPI_DATE_HOUR:
      return format_date($timestamp, 'custom', 'g A', 0);

    case FACETAPI_DATE_MINUTE:
      return format_date($timestamp, 'custom', 'g:i A', 0);

    case FACETAPI_DATE_SECOND:
      return format_date($timestamp, 'custom', 'g:i:s A', 0);

    default:
      return format_date($timestamp, 'custom', 'Y', 0);
  }
}

/**
 * Returns a formatted date based on the passed ISO date string and gap.
 *
 * @param $date
 *   A string containing the date as an ISO date string.
 * @param $gap
 *   A string containing the gap, see FACETAPI_DATE_* constants for valid
 *   values, defaults to YEAR.
 *
 * @return
 *   A gap-appropriate display date used in the facet link.
 */
function facetapi_date_format($date, $gap = FACETAPI_DATE_YEAR) {
  $timestamp = strtotime($date);
  return facetapi_timestamp_format($timestamp, $gap);
}

/**
 * Returns the next increment from the given ISO date and gap. This function is
 * useful for getting the upper limit of a date range from the given start
 * date.
 *
 * @param $date
 *   A string containing the date as an ISO date string.
 * @param $gap
 *   A string containing the gap, see FACETAPI_DATE_* constants for valid
 *   values, defaults to YEAR.
 *
 * @return
 *   A string containing the date, FALSE if the passed date could not be parsed.
 */
function facetapi_next_date_increment_get($date, $gap) {
  $pattern = '@(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})@';
  if (preg_match($pattern, $date, $match)) {

    // Increments the timestamp.
    switch ($gap) {
      case FACETAPI_DATE_MONTH:
        $match[2] += 1;
        break;
      case FACETAPI_DATE_DAY:
        $match[3] += 1;
        break;
      case FACETAPI_DATE_HOUR:
        $match[4] += 1;
        break;
      case FACETAPI_DATE_MINUTE:
        $match[5] += 1;
        break;
      case FACETAPI_DATE_SECOND:
        $match[6] += 1;
        break;
      default:
        $match[1] += 1;
        break;
    }

    // Gets the next incremenet.
    return facetapi_isodate(
      gmmktime($match[4], $match[5], $match[6], $match[2], $match[3], $match[1])
    );
  }
  return FALSE;
}

/**
 * Implementation of hook_facetapi_realms().
 */
function facetapi_facetapi_realms() {
  $realms = array();

  // Displays each facet in a separate block.
  $realms['block'] = array(
    'title' => t('Blocks'),
    'description' => t(
      'The <em>Blocks</em> realm displays each facet in a separate <a href="@block-page">block</a>. Users are able to refine their searches in a drill-down fassion similar to the Apache Solr Search Integration module\'s faceted search implementation.',
      array('@block-page' => url('admin/build/block/list', array('query' => array('destination' => $_GET['q']))))
    ),
    'weight' => -10,
    'sortable' => FALSE,
    'file' => 'facetapi.block.inc',
  );

  // Displays facets in a fieldset below the search form.
  $realms['fieldset'] = array(
    'title' => t('Fieldset'),
    'description' => t('The <em>Fieldset</em> realm displays facets as form elements in a fieldset below the search form that is similar in appearance to the core Search module\'s <em>Advanced search</em> fieldset.'),
    'file' => 'facetapi.fieldset.inc',
  );

  return $realms;
}

/**
 * Implementation of hook_block().
 */
function facetapi_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      module_load_include('inc', 'facetapi', 'facetapi.block');
      return facetapi_block_info();

    case 'view':
      module_load_include('inc', 'facetapi', 'facetapi.block');
      return facetapi_block_view($delta);
  }
}

/**
 * Implementation of hook_FORM_ID_form_alter().
 */
function facetapi_form_block_admin_display_form_alter(&$form, &$form_state) {
  if (!empty($_REQUEST['destination'])) {
    $form['#submit'][] = 'facetapi_block_admin_display_form_submit';
  }
}

/**
 * Processes facetapi_block_admin_display_form form submissions.
 */
function facetapi_block_admin_display_form_submit(&$form, &$form_state) {

}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function facetapi_form_search_form_alter(&$form, &$form_state) {
  // Makes sure we are dealing with a search that has a FacetAPI adapter.
  if (!$adapter = facetapi_adapter_load($form['module']['#value'])) {
    return;
  }

  // Renders the facets as form elements.
  $elements = facetapi_realm_render($form['module']['#value'], 'fieldset');
  if (!empty($elements)) {

    // Adds the fieldset realm to the search form.
    $form['facets'] = array(
      '#type' => 'fieldset',
      '#title' => t('Faceted search'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('class' => 'search-advanced'),
    );
    $form['facets'] = array_merge($form['facets'], $elements);
    $form['facets']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Search'),
      '#prefix' => '<div class="action">',
      '#suffix' => '</div>',
      '#weight' => 100,
    );

    // Adds facet data container, validate and submit handlers.
    $form['basic']['inline']['processed_facets'] = array('#type' => 'value', '#value' => '');
    $form['#validate'][] = 'facetapi_search_form_validate';
    $form['#submit'][] = 'facetapi_search_form_submit';
  }
}

/**
 * Validates search_form form submissions.
 */
function facetapi_search_form_validate($form, &$form_state) {

  // Captures facet values passed through the form, appends the value to the
  // facet definition so we have all the necessary information at hand.
  $facets = array();
  foreach (facetapi_enabled_facets_get($form['module']['#value']) as $facet) {
    if (isset($form_state['values'][$facet['field alias']])) {
      $value = $form_state['values'][$facet['field alias']];
      if (is_array($value)) {
        $value = array_filter($value);
      }
      if (!empty($value)) {
        $facet['values'] = $value;
        $facets[] = $facet;
      }
    }
  }

  // Stores facet definitions with passed values in the container.
  form_set_value($form['basic']['inline']['processed_facets'], $facets, $form_state);
}

/**
 * Processes search_form form submissions.
 */
function facetapi_search_form_submit($form, &$form_state) {
  if ($adapter = facetapi_adapter_load($form['module']['#value'])) {
    if (!empty($form_state['values']['processed_facets'])) {

      // Builds array of query string varialbes ,merges not only the array, but
      // the strings inside of an array.
      // @todo This is a hack, and needs to be fixed with an adapter method.
      $qstring = array();
      foreach ($form_state['values']['processed_facets'] as $facet) {
        if (!is_array($facet['values'])) {
          $facet['values'] = drupal_map_assoc((array)$facet['values']);
        }
        foreach ($adapter->getFacetQueryString($facet, $facet['values'], FALSE) as $key => $value) {
          if (!isset($qstring[$key])) {
            $qstring[$key] = $value;
          }
          else {
            $qstring[$key] .= ' '. $value;
          }
        }
      }

      // Redirects to appropriate search page with facet information in the
      // query string.
      $form_state['redirect'] = array(
        sprintf('search/%s/%s', $form['module']['#value'], facetapi_keys_encode(search_get_keys())),
        drupal_query_string_encode($qstring, array('q', 'page')),
      );
    }
  }
}

/**
 * Implementation of hook_facetapi_facets().
 */
function facetapi_facetapi_facets($searcher, $type) {
  $facets = array();
  if ('node' == $type) {

    $facets['type'] = array(
      'title' => t('Content type'),
      'description' => t('Filter by content type.'),
      'form type' => 'checkboxes',
      'map callback' => 'facetapi_node_type_map',
      'values callback' => 'facetapi_values_type',
    );

    $facets['author'] = array(
      'title' => t('Author'),
      'description' => t('Filter by author.'),
      'field' => 'uid',
      'form type' => 'textfield',
      'map callback' => 'facetapi_node_uid_map',
    );

    $facets['language'] = array(
      'title' => t('Language'),
      'description' => t('Filter by language.'),
      'form type' => 'checkboxes',
      'map callback' => 'facetapi_node_language_map',
      'values callback' => 'facetapi_values_language',
    );

    $facets['created'] = array(
      'title' => t('Post date'),
      'description' => t('Filter by the date the node was posted.'),
      'form type' => 'textfield',
      'query type' => 'date',
      'map callback' => 'facetapi_date_range_map',
    );

    $facets['changed'] = array(
      'title' => t('Updated date'),
      'description' => t('Filter by the date the node was last modified.'),
      'form type' => 'textfield',
      'query type' => 'date',
      'map callback' => 'facetapi_date_range_map',
    );

    // Adds taxonomy facets, breaks up into separate vocabularies.
    if (module_exists('taxonomy')) {
      foreach (taxonomy_get_vocabularies() as $voc) {
        $facet_name = 'vocabulary_'. $voc->vid;
        $facets[$facet_name] = array(
          'title' => $voc->name,
          'description' => t(
            'Filter by terms in the %vocabulary vocabulary.',
            array('%vocabulary' => $voc->name)
          ),
          'field' => 'category',
          'form type' => 'select',
          'map callback' => 'facetapi_taxonomy_term_map',
          'values callback' => 'facetapi_values_taxonomy',
        );

        // Adds hierarchy callback to get parent information.
        if (facetapi_vocabulary_hierarchical($voc->vid)) {
          $facets[$facet_name]['hierarchy callback'] = 'facetapi_taxonomy_hierarchy_callback';
        }
      }
    }
  }

  return $facets;
}

/**
 * Implementation of hook_facetapi_widgets().
 */
function facetapi_facetapi_widgets() {
  return array(
    'facetapi_links' => array(
      'title' => t('Links'),
      'callback' => 'facetapi_links_widget_callback',
      'weight' => -10,
    ),
    'facetapi_checkboxes' => array(
      'title' => t('Links with checkboxes'),
      'callback' => 'facetapi_checkboxes_widget_callback',
      'weight' => -5,
    ),
  );
}
