<?php

/**
 * @file
 * An abstracted facet API that can be used by various search backends.
 */

/**
 * Constant for the "AND" operator.
 */
define('FACETAPI_OPERATOR_AND', 'and');

/**
 * Constant for the "OR" operator.
 */
define('FACETAPI_OPERATOR_OR', 'or');

/**
 * String that represents a time gap of a year between two dates.
 */
define('FACETAPI_DATE_YEAR', 'YEAR');

/**
 * String that represents a time gap of a month between two dates.
 */
define('FACETAPI_DATE_MONTH', 'MONTH');

/**
 * String that represents a time gap of a day between two dates.
 */
define('FACETAPI_DATE_DAY', 'DAY');

/**
 * String that represents a time gap of an hour between two dates.
 */
define('FACETAPI_DATE_HOUR', 'HOUR');

/**
 * String that represents a time gap of a minute between two dates.
 */
define('FACETAPI_DATE_MINUTE', 'MINUTE');

/**
 * String that represents a time gap of a second between two dates.
 */
define('FACETAPI_DATE_SECOND', 'SECOND');

/**
 * Date string for ISO 8601 date formats.
 */
define('FACETAPI_DATE_ISO8601', 'Y-m-d\TH:i:s\Z');

/**
 * Regex pattern for range queries.
 */
define('FACETAPI_REGEX_RANGE', '/^[\[\{](\S+) TO (\S+)[\]\}]$/');

/**
 * Regex pattern for date queries.
 */
define('FACETAPI_REGEX_DATE', '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/');

/**
 * Regex pattern for date ranges.
 */
define('FACETAPI_REGEX_DATE_RANGE', '/^\[('. trim(FACETAPI_REGEX_DATE, '/^$') .') TO ('. trim(FACETAPI_REGEX_DATE, '/^$') .')\]$/');

/**
 * Implements hook_ctools_plugin_type().
 */
function facetapi_ctools_plugin_type() {
  return array(
    'adapters' => array(
      'use hooks' => TRUE,
    ),
    'realms' => array(
      'use hooks' => TRUE,
    ),
    'widgets' => array(
      'use hooks' => TRUE,
    ),
    'query_types' => array(
      'use hooks' => TRUE,
    ),
  );
}

////
////
//// facetapi_*_load() functions
////
////

/**
 * Loads an instantiated adapter plugin associated with the searcher.
 *
 * @param $searcher
 *   The machine readable name of searcher.
 *
 * @return FacetapiAdapter
 *   The adapter object, FALSE if not available.
 */
function facetapi_adapter_load($searcher) {
  $adapters = &drupal_static(__FUNCTION__, array());
  if (!isset($adapters[$searcher])) {
    $searcher_info = facetapi_get_searcher_info();
    if (isset($searcher_info[$searcher]['adapter'])) {
      ctools_include('plugins');
      $class = ctools_plugin_load_class('facetapi', 'adapters', $searcher_info[$searcher]['adapter'], 'handler');
      $adapters[$searcher] = ($class) ? new $class($searcher_info[$searcher]) : FALSE;
    }
  }
  return $adapters[$searcher];
}

/**
 * Returns a realm definition.
 *
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 *
 * @return
 *   An array containing the realm definition, FALSE if $realm_name is not
 *   valid.
 */
function facetapi_realm_load($realm_name) {
  $realm_info = facetapi_get_realm_info();
  return (isset($realm_info[$realm_name])) ? $realm_info[$realm_name] : FALSE;
}

/**
 * Loads a facet definition.
 *
 * NOTE: Facets aren't statically cached by this function, so avoid situations
 * where this needs to be called repeatedly. Use facetapi_enabled_facets_get()
 * as an alternative.
 *
 * @param $facet_name
 *   A string containing the machine readable name of the facet.
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 *
 * @return
 *   An array containing the facet definition, FALSE if $facet_name or $searcher
 *   is not valid.
 */
function facetapi_facet_load($facet_name, $searcher) {
  $facet_info = facetapi_get_facet_info($searcher);
  return (isset($facet_info[$facet_name])) ? $facet_info[$facet_name] : FALSE;
}

////
////
//// facetapi_get_*() functions
////
////

/**
 * Returns array of searcher information.
 */
function facetapi_get_searcher_info() {
  $searcher_info = module_invoke_all('facetapi_searcher_info');
  foreach ($searcher_info as $searcher => $info) {
    $searcher_info[$searcher] += array(
      'name' => $searcher,
    );
  }
  drupal_alter('facetapi_searcher_info', $searcher_info);
  return $searcher_info;
}

/**
 * Invokes hook_facetapi_realm_info(), returns realm definitions.
 *
 * @return
 *   An array of realm definitions.
 */
function facetapi_get_realm_info() {
  $realm_info = &drupal_static(__FUNCTION__);
  if (NULL === $realm_info) {

    // Gets realm info from hooks, merges with defaults.
    $realm_info = module_invoke_all('facetapi_realm_info');
    foreach ($realm_info as $realm_name => $realm) {
      $realm_info[$realm_name] += array(
        'name' => $realm_name,
        'label' => $realm_name,
        'description' => '',
        'default widget' => '',
        'widget requirements' => array(),
        'weight' => 0,
        'sortable' => TRUE,
        'ui' => TRUE,
      );
    }

    // Invokes alter hook, sorts realms by weight.
    drupal_alter('facetapi_realm_info', $realm_info);
    uasort($realm_info, 'drupal_sort_weight');
  }

  return $realm_info;
}

/**
 * Invokes hook_facetapi_facet_info(), returns all defined facets.
 *
 * @param FacetapiAdapter $adapter
 *
 * @return
 *   An array containing the facet arrays, FALSE on errors.
 */
function facetapi_get_facet_info($searcher) {
  $facets = array();

  // Gets facets from hooks and the modules the facets are defined in.
  foreach (module_implements('facetapi_facet_info') as $module) {
    $module_facets = module_invoke($module, 'facetapi_facet_info', $searcher);
    foreach ($module_facets as $facet_name => $facet) {

      // Builds array of default values.
      $facets[$facet_name] = $facet + array(
        'name' => $facet_name,
        'label' => $facet_name,
        'description' => '',
        'field' => $facet_name,
        'field alias' => isset($facet['field']) ? $facet['field'] : $facet_name,
        'query type' => 'term',
        'data group' => FALSE,
        'widget requirements' => array(),
        'default widgets' => array(),
        'weight' => 0,
        'map callback' => FALSE,
        'hierarchy callback' => FALSE,
        'values callback' => FALSE,
        'min callback' => FALSE,
        'max callback' => FALSE,
        'file' => '',
        'file path' => drupal_get_path('module', $module),
        'default sorts' => array(
          array('active', SORT_DESC),
          array('count', SORT_DESC),
          array('display', SORT_ASC),
        ),
      );

      // Checks whether facet is flat or hierarchical, adds to requirements.
      if (!$facets[$facet_name]['hierarchy callback']) {
        $facets[$facet_name]['widget requirements'][] = 'flat';
      }
      else {
        $facets[$facet_name]['widget requirements'][] = 'hierarchical';
      }
    }

    // Invokes alter hook to allow modules to modify facet definitions.
    drupal_alter('facetapi_facet_info', $facets, $searcher, $type);
  }

  // Sorts facets by weight, returns facets.
  uasort($facets, 'drupal_sort_weight');
  return $facets;
}

/**
 * Invokes hook_facetapi_widget_info(), returns all defined widgets.
 *
 * @param $variables
 *   An array of variables passed to the restriction callbacks. By default it
 *   contains the adapter, realm definition, and facet definition. If the array
 *   is empty, all widgets will be returned.
 *
 * @return
 *   An associative array of widget definitions keyed by widget name.
 */
function facetapi_get_widget_info(array $variables = array()) {
  $widget_info = &drupal_static(__FUNCTION__);
  if (NULL === $widget_info) {

    // Gets widgets from hooks, merges with defaults.
    foreach (module_implements('facetapi_widget_info') as $module) {
      $module_widgets = module_invoke($module, 'facetapi_widget_info');
      foreach ($module_widgets as $widget_name => $widget) {
        $widget_info[$widget_name] = $widget + array(
          'label' => t('Widget'),
          'callback' => 'facetapi_links_widget_callback',
          'widget requirements' => array(),
          'variables' => array(),
          'weight' => 0,
          'module' => $module,
        );
      }
    }

    // Allows modules to alter the widget defintions.
    drupal_alter('facetapi_widget_info', $widget_info);
  }

  // If variables passed, returns widgets the facet has access to.
  if (!empty($variables)) {
    $return = $widget_info;
    foreach ($widget_info as $widget_name => $widget) {
      $return[$widget_name]['variables'] = array_merge(
        $variables, $widget_info[$widget_name]['variables']
      );
    }
    return array_filter($return, 'facetapi_filter_widgets');
  }
  else {
    return $widgets;
  }
}

/**
 * Finds a facet's selected widget given the searcher and realm.
 *
 * @param $widgets
 *   An array of widget definitions.
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm
 *   An array containing the full realm definition.
 * @param $facet
 *   An array containing the full realm definition.
 *
 * @return
 *   A string containing the default widget.
 */
function facetapi_get_facet_widget(array $widgets, $searcher, array $realm, array $facet) {
  if (!$widget_name = facetapi_setting_get('widget', $searcher, $realm['name'], $facet['name'])) {
    foreach ($facet['default widgets'] as $default_widget) {
      if (isset($widgets[$default_widget])) {
        $widget_name = $default_widget;
        break;
      }
    }
    if (!$widget_name) {
      $widget_name = $realm['default widget'];
    }
  }
  return $widget_name;
}

/**
 * Invokes hook_facetapi_sort_info(), returns all defined sorts.
 *
 * @return
 *   An associative array of sort definitions keyed by sort name.
 */
function facetapi_get_sort_info() {
  $sort_info = &drupal_static(__FUNCTION__);
  if (NULL === $sort_info) {

    // Gets realm info from hooks, merges with defaults.
    $sort_info = module_invoke_all('facetapi_sort_info');
    foreach ($sort_info as $sort_name => $info) {
      $sort_info[$sort_name] += array(
        'name' => $sort_name,
        'title' => $sort_name,
        'callback' => '',
        'description' => '',
        'weight' => 0,
      );
    }

    // Invokes alter hook.
    drupal_alter('facetapi_sort_info', $sort_info);
  }
  return $sort_info;
}

////
////
//// Facet API hook implementations
////
////

/**
 * Implements hook_facetapi_realm_info().
 */
function facetapi_facetapi_realm_info() {
  $realms = array();

  // Displays each facet in a separate block.
  $realms['block'] = array(
    'label' => t('Blocks'),
    'weight' => -10,
    'sortable' => FALSE,
    'default widget' => 'facetapi_links',
    'widget requirements' => array('list'),
    'description' => t(
      'The <em>Blocks</em> realm displays each facet in a separate <a href="@block-page">block</a>. Users are able to refine their searches in a drill-down fassion similar to the Apache Solr Search Integration module\'s faceted search implementation.',
      array('@block-page' => url('admin/structure/block', array('query' => array('destination' => $_GET['q']))))
    ),
  );

  // Displays facets in a fieldset below the search form.
  $realms['fieldset'] = array(
    'label' => t('Fieldset'),
    'weight' => -5,
    'default widget' => 'facetapi_textfield',
    'widget requirements' => array('form'),
    'description' => t('The <em>Fieldset</em> realm displays facets as form elements in a fieldset below the search form that is similar in appearance to the core Search module\'s <em>Advanced search</em> fieldset.'),
  );

  return $realms;
}

/**
 * Implements hook_facetapi_facet_info().
 */
function facetapi_facetapi_facet_info($searcher) {
  $facets = array();
  //if ('node' == $type) {

    $facets['type'] = array(
      'label' => t('Content type'),
      'description'=> t('Filter by content type.'),
      'map callback'=> 'facetapi_callback_type_map',
      'values callback' => 'facetapi_callback_type_values',
      'widget requirements'=> array('has default values'),
      'default widgets' => array('facetapi_checkboxes'),
      'file'=> 'facetapi.callbacks.inc',
    );

    $facets['author'] = array(
      'label' => t('Author'),
      'description' => t('Filter by author.'),
      'field' => 'uid',
      'data group' => 'user',
      'widget requirements' => array('has default values'),
      'map callback' => 'facetapi_callback_uid_map',
      'values callback' => 'facetapi_callback_user_values',
      'file' => 'facetapi.callbacks.inc',
    );

    $facets['language'] = array(
      'label' => t('Language'),
      'description' => t('Filter by language.'),
      'widget requirements' => array('has default values'),
      'default widgets' => array('facetapi_checkboxes'),
      'map callback' => 'facetapi_callback_language_map',
      'values callback' => 'facetapi_callback_language_values',
      'file' => 'facetapi.callbacks.inc',
    );

    $facets['created'] = array(
      'label' => t('Post date'),
      'description' => t('Filter by the date the node was posted.'),
      'widget requirements' => array('date'),
      'query type' => 'date',
      'map callback' => 'facetapi_callback_date_map',
      'min callback' => 'facetapi_callback_min_date',
      'max callback' => 'facetapi_callback_max_date',
      'file' => 'facetapi.callbacks.inc',
      'default sorts' => array(
        array('active', SORT_DESC),
        array('indexed', SORT_ASC),
      ),
    );

    $facets['changed'] = array(
      'label' => t('Updated date'),
      'description' => t('Filter by the date the node was last modified.'),
      'widget requirements' => array('date'),
      'query type' => 'date',
      'map callback' => 'facetapi_callback_date_map',
      'min callback' => 'facetapi_callback_min_date',
      'max callback' => 'facetapi_callback_max_date',
      'file' => 'facetapi.callbacks.inc',
      'default sorts' => array(
        array('active', SORT_DESC),
        array('indexed', SORT_ASC),
      ),
    );
  //}

  return $facets;
}

/**
 * Implementation of hook_facetapi_sort_info().
 */
function facetapi_facetapi_sort_info() {
  $sorts = array();

  $sorts['active'] = array(
    'label' => t('Facet active'),
    'callback' => 'facetapi_sort_active',
    'description' => t('Sort by whether the facet is active or not.'),
    'weight' => -50,
  );

  $sorts['count'] = array(
    'label' => t('Count'),
    'callback' => 'facetapi_sort_count',
    'description' => t('Sort by the facet count.'),
    'weight' => -49,
  );

  $sorts['display'] = array(
    'label' => t('Display value'),
    'callback' => 'facetapi_sort_display',
    'description' => t('Sort by the value displayed to the user.'),
    'weight' => -48,
  );

  $sorts['indexed'] = array(
    'label' => t('Indexed value'),
    'callback' => 'facetapi_sort_indexed',
    'description' => t('Sort by the raw value stored in the index.'),
    'weight' => -47,
  );

  return $sorts;
}

/**
 * Implements hook_facetapi_widget_info().
 */
function facetapi_facetapi_widget_info() {
  $widgets = array();

  $widgets['facetapi_links'] = array(
    'label' => t('Links'),
    'callback' => 'facetapi_widget_links',
    'widget requirements' => array('list'),
    'file' => 'facetapi.widget.inc',
    'weight' => -10,
  );

  $widgets['facetapi_link_checkboxes'] = array(
    'label' => t('Links with checkboxes'),
    'callback' => 'facetapi_widget_link_checkboxes',
    'widget requirements' => array('list'),
    'file' => 'facetapi.widget.inc',
    'weight' => -9,
  );

  $widgets['facetapi_checkboxes'] = array(
    'label' => t('Checkboxes'),
    'callback' => 'facetapi_widget_checkboxes',
    'widget requirements' => array('form', 'has default values', 'flat'),
    'file' => 'facetapi.widget.inc',
    'weight' => -10,
  );

  $widgets['facetapi_radios'] = array(
    'label' => t('Radios'),
    'callback' => 'facetapi_widget_radios',
    'widget requirements' => array('form', 'has default values', 'flat'),
    'file' => 'facetapi.widget.inc',
    'weight' => -9,
  );

  $widgets['facetapi_select'] = array(
    'label' => t('Select list'),
    'callback' => 'facetapi_widget_select',
    'widget requirements' => array('form', 'has default values'),
    'file' => 'facetapi.widget.inc',
    'weight' => -8,
  );

  $widgets['facetapi_multiselect'] = array(
    'label' => t('Multiple value select list'),
    'callback' => 'facetapi_widget_multiselect',
    'widget requirements' => array('form', 'has default values'),
    'file' => 'facetapi.widget.inc',
    'weight' => -7,
  );

  $widgets['facetapi_textfield'] = array(
    'label' => t('Text field'),
    'callback' => 'facetapi_widget_textfield',
    'widget requirements' => array('form'),
    'file' => 'facetapi.widget.inc',
    'weight' => -6,
  );

  return $widgets;
}

/**
 * Filters widgets by invoking their access callbacks.
 *
 * @param $widget
 *   An array containing the widget info.
 *
 * @return
 *   A boolean flagging whether the item should be kept in the array.
 */
function facetapi_filter_widgets(array $widget) {
  // Captures variables for code readability.
  $realm_reqs = $widget['variables']['realm']['widget requirements'];
  $facet_reqs = $widget['variables']['facet']['widget requirements'];

  // Gets what requirements we have, what's required, which ones are common.
  $reqs = array_unique(array_merge($realm_reqs, $facet_reqs));
  $required = array_unique($widget['widget requirements']);
  $common = array_intersect($reqs, $required);

  // Makes sure all requirements are met.
  sort($required);
  sort($common);
  return ($common == $required);
}

////
////
//// Utility functions
////
////

/**
 * Loads settings from the database.
 *
 * @param FacetapiAdapter $adapter
 *   The adapter loading the facets.
 *
 * @return array
 */
function facetapi_get_enabled_facets($searcher, $realm = NULL) {
  $enabled_facets = &drupal_static(__FUNCTION__);
  if (NULL === $enabled_facets) {
    // Builds array of aruments to pass to ctools_export_load_object().
    $args = array('searcher' => $searcher,  'enabled' => 1);
    if (NULL !== $realm) {
      $args['realm'] = $realm;
    }

    // Loads settings for enabled facets.
    ctools_include('export');
    $results = ctools_export_load_object('facetapi', 'conditions', $args);

    // Builds an array keyed by the names of enabled facets.
    $facets = array();
    foreach ($results as $result) {
      $facets[$result->facet] = $result->facet;
    }

    // Gets facet definitions for all enabled facets.
    $facet_info = facetapi_get_facet_info($searcher);
    $enabled_facets = array_intersect_key($facet_info, $facets);
  }
  return $enabled_facets;
}

/**
 * Tests whether a single facet is enabled in a given realm.
 *
 * @param $searcher
 *   The machine readable name of the searcher.
 * @param $realm_name
 *   The machine readable name of the realm, pass NULL to test if the facet is
 *   enabled in at least one realm.
 * @param $facet_name
 *   The machine readable name of the facet.
 *
 * @return
 *   A boolean flagging whether the facet is enabled in the passed realm.
 */
function facetapi_facet_enabled($searcher, $realm_name, $facet_name) {
  $enabled_facets = facetapi_get_enabled_facets($searcher, $realm_name, $facet_name);
  return isset($enabled_facets[$facet_name]);
}

/**
 * Applies facet filters to the query.
 *
 * @param $searcher
 *   The machine readable name of the searcher.
 * @param stdClass $query
 *   The query in the backend's native API.
 */
function facetapi_add_facets($searcher, $query) {
  $adapter = facetapi_adapter_load($searcher);
  foreach (facetapi_get_enabled_facets($searcher) as $facet) {
    $adapter->addFacetQuery($facet, $query);
  }
}

/**
 * Builds a facet realm.
 *
 * Converts the facet data into a render array suitable for passing to the
 * drupal_render() function.
 *
 * @param $searcher
 *   A string containing the machine readable name of the searcher module.
 * @param $realm_name
 *   A string containing the machine readable name of the realm.
 *
 * @return
 *   The realm's render array.
 */
function facetapi_build_realm($searcher, $realm_name) {
  $adapter = facetapi_adapter_load($searcher);
  return ($adapter) ? $adapter->buildRealm($realm_name) : array();
}

////
////
//// Block realm code
////
////

/**
 * Implements hook_block_info().
 */
function facetapi_block_info() {
  $blocks = array();

  // Gets delta map, iterates over all enabled facets.
  $map = facetapi_get_delta_map();
  foreach (facetapi_get_searcher_info() as $searcher => $info) {
    $facets = facetapi_get_enabled_facets($searcher, 'block');
    foreach ($facets as $facet_name => $facet) {

      // Gets the delta from the delta map.
      $string = $searcher . ':block:' . $facet_name;
      $delta = array_search($string, $map);

      // Defines the block.
      // @todo Explore more efficient caching options.
      $blocks[$delta] = array(
        'info' => 'Facet API: ' . $info['label'] . ' : ' . $facet['label'],
        //'cache' => BLOCK_NO_CACHE,
      );
    }
  }

  // Returns available blocks.
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function facetapi_block_view($delta = '') {
  $builds = &drupal_static(__FUNCTION__, array());

  // Bails if delta isn't mapped.
  $map = facetapi_get_delta_map();
  if (!isset($map[$delta])) {
    return array();
  }

  // Extracts the searcher, realm name, and facet name from $delta.
  list($searcher, $realm_name, $facet_name) = explode(':', $map[$delta]);
  $group = $searcher . ':' . $realm_name;

  // Bails if a search hasn't been executed.
  // @todo Handle empty searches.
  if ((!$adapter = facetapi_adapter_load($searcher)) || !$adapter->searchExecuted()) {
    return array();
  }

  // Builds and caches the entire realm per searcher / realm combination.
  if (!isset($builds[$group])) {
    $builds[$group] = facetapi_build_realm($searcher, $realm_name);
  }

  // Returns the individual block.
  if (isset($builds[$group][$facet_name])) {
    return array(
      'subject' => NULL,
      'content' => drupal_render($builds[$group][$facet_name]),
    );
  }
}

/**
 * Returns a cached delta map of md5 hashes to names.
 *
 * Sometimes our deltas are longer than 32 chars and need to be passed to md5().
 * Due to the block table's schema, deltas cannot be longer than 32 characters.
 * However, md5 hashes are nasty as CSS IDs, so we can use the map to convert
 * the md5 back to a nicer value in facetapi_preprocess_block().
 *
 * @return
 *   An array containing the delta map.
 */
function facetapi_get_delta_map() {
  $map = &drupal_static(__FUNCTION__);
  if (NULL === $map) {
    if ($data = cache_get('facetapi:delta_map')) {
      $map = $data->data;
    }
    else {
      $map = array();

      // Calculates deltas for each enabled facet in each realm for all
      // available searchers.
      foreach (facetapi_get_searcher_info() as $searcher => $info) {
        foreach (facetapi_get_realm_info() as $realm) {
          foreach (facetapi_get_enabled_facets($searcher, $realm['name']) as $facet) {
            $string = $searcher . ':' . $realm['name'] . ':' . $facet['name'];
            // NOTE: We don't need drupal_strlen() becuase there will be no UTF8
            // characters in this string, and strlen() is much faster.
            // @todo Is this a bad assumption?
            $key = (strlen($string) <= 32) ? $string : md5($string);
            $map[$key] = $string;
          }
        }
      }

      // Caches the map so we don't have to do this repeatedly.
      cache_set('facetapi:delta_map', $map, 'cache', CACHE_TEMPORARY);
    }
  }

  return $map;
}
