<?php

/**
 * @file
 * Tests for the Facet API module.
 */

/**
 * Base class for all Facet API test cases.
 */
class FacetapiTestCase extends DrupalWebTestCase {

  /**
   * Overrides DrupalWebTestCase::fetchAssoc().
   *
   * Enables the "block" and "facetapi_test" modules, creates an administrative
   * user with permissions to configure the Faceted Search interface.
   */
  public function setUp() {
    parent::setUp('block', 'facetapi_test');
    $this->authenticatedUser = $this->drupalCreateUser();
    $this->adminUser = $this->drupalCreateUser(array(
      'administer blocks',
      'administer search',
      'access administration pages',
    ));
  }

  /**
   * Instantiates the adapter plugin associated with the searcher.
   *
   * The following tests are executed:
   *   - DrupalTestCase::assertTrue(): Asserts that FALSE is not returned by
   *     facetapi_adapter_load().
   *
   * @param string $searcher
   *   The machine readable name of the searcher.
   *
   * @return FacetapiAdapter
   *   The adapter object, FALSE if the object can't be loaded.
   *
   * @see facetapi_adapter_load().
   */
  public function loadAdapter($searcher) {
    $adapter = facetapi_adapter_load('facetapi_test');
    $value = ($adapter instanceof FacetapiAdapter);
    $this->assertTrue($value, t('FacetapiAdapter object loaded via facetapi_adapter_load().'), 'Facet API');
    return $adapter;
  }

  /**
   * Overrides DrupalWebTestCase::drupalPost()
   *
   * Clears static variables on settings submission. This is OK because the
   * script execution persists when the form is submitted by the test unlike a
   * real form post where the page has to reload.
   */
  public function drupalPost($path, $edit, $submit, array $options = array(), array $headers = array(), $form_html_id = NULL, $extra_post = NULL) {
    parent::drupalPost($path, $edit, $submit, $options, $headers, $form_html_id, $extra_post);
    if (t('Save configuration') == $submit) {
      drupal_static('facetapi_get_searcher_settings', array(), TRUE);
      drupal_static('facetapi_get_enabled_facets', array(), TRUE);
    }
  }

  /**
   * Enables a facet in the block realm, adds it to the "sidebar_first" region.
   *
   * The following tests are executed:
   *   - DrupalTestCase::getPath(): Retrieves path to the administrative
   *     settings page for the block realm.
   *   - DrupalTestCase::getPost(): Enables the facet in the block realm.
   *   - DrupalTestCase::assertRaw(): Ensures the configuration options were
   *     successful by testing for the confirmation message.
   *   - DrupalTestCase::assertTrue(): Double checks that the facet is enabled
   *     via the facetapi_facet_enabled() API function.
   *   - DrupalTestCase::getPost(): Activates the facet block in the
   *     "sidebar_first" region.
   *   - DrupalTestCase::getPath(): Retrieves path to the search page.
   *   - DrupalTestCase::assertRaw(): Tests if the block is displayed by
   *     looking for it's title.
   *
   * @param string $facet_name
   *   The machine readable name of the facet.
   * @param string $label
   *   The title of the block whose existence is being tested.
   * @param string $realm_name
   *   The machine readable name of the realm.
   */
  public function enableFacet($facet_name, $label, $realm_name = 'block') {
    $path = 'admin/config/search/facetapi_test/facets/' . $realm_name;

    // Posts the form, ensures it was successfully submitted.
    $values = array('enabled_facets[' . $facet_name . ']' => $facet_name);
    $this->drupalGet($path);
    $this->drupalPost($path, $values, t('Save configuration'));
    $this->assertRaw(t('The configuration options have been saved.'), t('Facet form successfully submitted.'), 'Facet API');

    // Tests the status of the enabled facet.
    $value = facetapi_facet_enabled('facetapi_test', $realm_name, $facet_name);
    $this->assertTrue($value, t('Facet enabled via the interface.'), 'Facet API');

    // Adds realm to block if we are testing the block realm.
    if ('block' == $realm_name) {

      // Generates the "key" by generating and hashing the delta.
      module_load_include('inc', 'facetapi', 'facetapi.block');
      $detla = facetapi_build_delta('facetapi_test', $realm_name, $facet_name);
      $key = 'facetapi_' . facetapi_hash_delta($detla);

      // Enables the facet in the "sidebar_first" region.
      $edit = array('blocks[' . $key . '][region]' => 'sidebar_first');
      $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));

      // Visits search page, raw value mimics return from default theme function.
      $this->drupalGet('facetapi_test/search');
      $raw = t('Filter by @title:', array('@title' => drupal_strtolower($label)));
      $this->assertRaw($raw, t('Facet block displayed on search page.'), 'Facet API');
    }
  }
}

class FacetapiAdapterTestCase extends FacetapiTestCase {

  public static function getInfo() {
    return array(
      'name' => 'Adapter functionality',
      'description' => 'Tests the adapter system.',
      'group' => 'Facet API',
    );
  }

  public function testValidAdapter() {
    // Tests loading of a valid adapter plugin, sets a semaphore to see if
    // singleton pattern is implemented.
    $adapter1 = $this->loadAdapter('facetapi_test');
    $adapter1->semaphore = 'test';
    $adapter2 = $this->loadAdapter('facetapi_test');
    $value = (isset($adapter2->semaphore) && 'test' == $adapter2->semaphore);
    $this->assertTrue($value, t('Singleton pattern implemented by facetapi_adapter_load().'), 'Facet API');
  }

  public function testInvalidAdapter() {
    $adapter = facetapi_adapter_load('bad_adapter');
    $this->assertFalse($adapter, t('Loading an invalid adapter returns FALSE.'), 'Facet API');
  }

  public function testSetParams() {
    // Sets dummy parameters.
    $adapter = facetapi_adapter_load('facetapi_test');
    $url = drupal_parse_url('http://example.com/index.php?q=test&page=1&f[0]=bundle:page');
    $adapter->setParams($url['query']);

    // Ensures that the "q" and "page" variables are stripped.
    $params = $adapter->getUrlProcessor()->getParams();
    $this->assertTrue(!isset($params['q']), t('The "q" variable is stripped by FacetapiAdapter::setParams().'), 'Facet API');
    $this->assertTrue(!isset($params['page']), t('The "page" variable is stripped by FacetapiAdapter::setParams().'), 'Facet API');

    // Tests that the "bundle:page" variable is set.
    $value = (isset($params['f'][0]) && 'bundle:page' == $params['f'][0]);
    $this->assertTrue($value, t('Facet value captured via FacetapiAdapter::setParams().'), 'Facet API');
  }
}

class FacetapiAdminInterfaceTestCase extends FacetapiTestCase {
  protected $authenticatedUser;
  protected $adminUser;

  public static function getInfo() {
    return array(
      'name' => 'Administrative UI',
      'description' => 'Tests the UI for Facet API administrative pages.',
      'group' => 'Facet API',
    );
  }

  public function testFormAccess() {
    $this->drupalLogin($this->authenticatedUser);

    $this->drupalGet('admin/config/search/facetapi_test/facet');
    $this->assertResponse(403, t('The "administer search" permission is required to access the realm settings form.'), 'Facet API');

    // @todo Randomize facet / realm combination?
    $this->drupalGet('admin/config/search/facetapi/facetapi_test/block/enabled/edit');
    $this->assertResponse(403, t('The "administer search" permission is required to access the facet settings form.'), 'Facet API');

    $this->drupalGet('admin/config/search/facetapi/facetapi_test/block/enabled/dependencies');
    $this->assertResponse(403, t('The "administer search" permission is required to access the facet dependencies form.'), 'Facet API');

    $this->drupalGet('admin/config/search/facetapi/facetapi_test/block/enabled/export');
    $this->assertResponse(403, t('The "administer search" permission is required to access the facet export form.'), 'Facet API');
  }

  public function testRealmSettingsForms() {
    $this->drupalLogin($this->adminUser);

    // Looks for placeholder text in main settings form.
    $this->drupalGet('admin/config/search/facetapi_test');
    $this->assertRaw(FACETAPI_TEST_FORM_TEXT, t('Facet API test setting form exists.'), 'Facet API');

    // Searches for "block" link in description.
    $description = t(
      'The <em>Blocks</em> realm displays each facet in a separate <a href="@block-page">block</a>. Users are able to refine their searches in a drill-down fashion.',
      array('@block-page' => url('admin/structure/block', array('query' => array('destination' => 'admin/config/search/facetapi_test/facets/block'))))
    );
    $this->drupalGet('admin/config/search/facetapi_test/facets/block');
    $this->assertRaw($description, t('Facet API test facet form exists.'), 'Facet API');
  }

  public function testEnableFacet() {
    $this->drupalLogin($this->adminUser);
    $this->enableFacet('enabled', t('Enabled facet'));
  }
}

class FacetapiSearchPageInterfaceTestCase extends FacetapiTestCase {
  protected $authenticatedUser;
  protected $adminUser;

  public static function getInfo() {
    return array(
      'name' => 'Search page UI',
      'description' => 'Tests the UI for search pages.',
      'group' => 'Facet API',
    );
  }

  public function testFormAccess() {
    $this->drupalLogin($this->adminUser);
    $this->enableFacet('enabled', t('Enabled facet'));
    $this->drupalLogin($this->authenticatedUser);

    // @todo Randomize keys.

    // Tests breadcrumb trail when search keys are in the path.
    $path = 'facetapi_test/search/testkeys';
    $options = array('query' => array('f' => array(0 => 'enabled:testone')));
    $this->drupalGet($path, $options);
    $this->clickLink('testkeys');
    $this->assertUrl($path);

    // Tests breadcrumb trail when search keys are in the query string.
    $path = 'facetapi_test/search';
    $options = array('query' => array('keys' => 'testkeys', 'f' => array(0 => 'enabled:testone')));
    $this->drupalGet($path, $options);
    $this->clickLink('testkeys');
    $this->assertUrl($path, array('query' => array('keys' => 'testkeys')));
  }

}

class FacetapiBugFixTestCase extends FacetapiTestCase {
  protected $authenticatedUser;
  protected $adminUser;

  public static function getInfo() {
    return array(
      'name' => 'Bug Fixes',
      'description' => 'Tests fixed bugs to prevent regressions.',
      'group' => 'Facet API',
    );
  }

  /**
   * Sets debug message flagging which issue was just tested.
   *
   * @param string $issue
   *   The URL to the issue on Drupal.org.
   */
  public function setIssueMessage($issue) {
    $href = check_plain($issue);
    $link = '<a href="' . $href . '">' . $href . '</a>';
    $this->pass(t('Tested issue !link', array('!link' => $link)), 'Debug');
  }

  /**
   * Tests bug fixed at http://drupal.org/node/1209490.
   */
  public function testEnableFacetWithColon() {
    $this->drupalLogin($this->adminUser);
    $this->enableFacet('colon:test', t('Colon test'));
    $this->setIssueMessage('http://drupal.org/node/1209490');
  }

  /**
   * Tests bug fixed at http://drupal.org/node/1443340.
   */
  public function testValidDefaults() {
    $this->drupalLogin($this->adminUser);
    $this->enableFacet('enabled', t('Enabled facet'));

    $path = 'admin/config/search/facetapi/facetapi_test/block/defaults/edit';
    $values = array('widget' => 'facetapi_nonterm');
    $this->drupalGet($path);
    $this->drupalPost($path, $values, t('Save configuration'));

    if ($adapter = $this->loadAdapter('facetapi_test')) {
      $facet = facetapi_facet_load('defaults', 'facetapi_test');
      $settings = $adapter->getFacetSettingsGlobal($facet);
      $message = t('Defaults settings not hard coded to "term" and FACETAPI_OPERATOR_AND.');
      $this->assertEqual($settings->settings['query_type'], 'nonterm', $message, 'Facet API');
    }

    $this->setIssueMessage('http://drupal.org/node/1443340');
  }
}

class FacetapiApiFunctions extends FacetapiTestCase {
  protected $authenticatedUser;
  protected $adminUser;

  public static function getInfo() {
    return array(
      'name' => 'API Functions',
      'description' => 'Tests low level API functions.',
      'group' => 'Facet API',
    );
  }

  /**
   * Tests the facetapi_facet_enabled() function.
   *
   * @see facetapi_facet_enabled()
   */
  public function testFacetEnabled() {
    $enabled = facetapi_facet_enabled('facetapi_test', 'nodisaply', 'enabled');
    $this->assertFalse($enabled, t('Facet flagged as disabled by facetapi_facet_enabled().'), 'Facet API');

    // Enables the facet via the GUI.
    $this->drupalLogin($this->adminUser);
    $this->enableFacet('enabled', t('Enabled facet'), 'nodisaply');
    $this->drupalLogin($this->authenticatedUser);

    $enabled = facetapi_facet_enabled('facetapi_test', 'nodisaply', 'enabled');
    $this->assertTrue($enabled, t('Facet flagged as enabled by facetapi_facet_enabled().'), 'Facet API');
  }

  /**
   * Tests facetapi_save_facet_status() API functions.
   *
   * @see facetapi_save_facet_status()
   * @see facetapi_save_facet_enabled()
   * @see facetapi_save_facet_disabled()
   */
  public function testSaveFacetStatus() {
    $adapter = facetapi_adapter_load('facetapi_test');
    $realm = facetapi_realm_load('nodisaply');
    $facet = facetapi_facet_load('enabled', 'facetapi_test');

    facetapi_save_facet_enabled($adapter, $realm, $facet);
    $enabled = facetapi_facet_enabled('facetapi_test', 'nodisaply', 'enabled');
    $this->assertTrue($enabled, t('Facet enabled by facetapi_save_facet_enabled().'), 'Facet API');

    facetapi_save_facet_disabled($adapter, $realm, $facet);
    $enabled = facetapi_facet_enabled('facetapi_test', 'nodisaply', 'enabled');
    $this->assertFalse($enabled, t('Facet disabled by facetapi_save_facet_disabled().'), 'Facet API');
  }

  /**
   * Tests facetapi_set_facet_status() API functions.
   *
   * @see facetapi_set_facet_status()
   * @see facetapi_set_facet_enabled()
   * @see facetapi_set_facet_disabled()
   */
  public function testSetFacetStatus() {
    $adapter = facetapi_adapter_load('facetapi_test');
    $realm = facetapi_realm_load('nodisaply');
    $facet = facetapi_facet_load('enabled', 'facetapi_test');

    // Facet disabled by default, tests temporarily overriding status. Although
    // the setting is disabled, status should be TRUE.
    facetapi_set_facet_enabled('facetapi_test', 'nodisaply', 'enabled');
    $enabled = facetapi_facet_enabled('facetapi_test', 'nodisaply', 'enabled');
    $this->assertTrue($enabled, t('Facet temporarily enabled by facetapi_set_facet_disabled().'), 'Facet API');

    // Saves facet as enabled, tests temporarily overriding status. Although the
    // setting is enabled, status should be FALSE.
    facetapi_save_facet_enabled($adapter, $realm, $facet);
    facetapi_set_facet_disabled('facetapi_test', 'nodisaply', 'enabled');
    $enabled = facetapi_facet_enabled('facetapi_test', 'nodisaply', 'enabled');
    $this->assertFalse($enabled, t('Facet temporarily disabled by facetapi_set_facet_disabled().'), 'Facet API');
  }

  /**
   * Tests the facetapi_translate_string() functionality.
   *
   * The Facet API Test module is not set as the translator module, so we do it
   * by setting the variable in this function. This prevetns it from interfering
   * with other tests.
   *
   * @see facetapi_translate_string().
   */
  public function testTranslateString() {
    // Sets Facet API Test as the translator module.
    variable_set('facetapi:translator_module', 'facetapi_test');
    $translated = facetapi_translate_string('name', 'untranslated');
    $this->assertEqual($translated, 'translated', t('String translated by facetapi_translate_string().'), 'Facet API');
  }
}
